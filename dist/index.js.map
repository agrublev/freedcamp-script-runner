{"version":3,"sources":["lib/release/sort.js","lib/release/bump.js","lib/helpers.js","lib/generateFScripts.js","lib/parseScriptsMd.js","lib/generateToc.js","lib/upgradePackages.js","lib/runCLICommand.js","lib/runSequence.js","lib/runParallel.js","lib/taskList.js","lib/parseScriptsPackage.js","lib/startScripts.js","lib/optionList.js","lib/git/validateNotDev.js","lib/encryption/encryption.js","index.js"],"names":["sortObjectKeys","require","detectIndent","sortOrder","defaultNpmScripts","sortPackageJson","packageJson","options","determinedSortOrder","wasString","hasWindowsNewlines","endCharacters","indentLevel","indent","substr","newlineMatch","match","JSON","parse","prefixedScriptRegex","prefixableScripts","slice","sortSubKey","key","sortList","unique","Array","isArray","sort","filter","el","index","arr","indexOf","toSortKey","script","prefixOmitted","replace","includes","compareScriptKeys","a","b","aScript","bScript","scripts","Object","keys","forEach","push","result","stringify","module","exports","main","fs","process","argv","cwd","filePath","readFileSync","sorted","writeFileSync","console","log","versiony","inquirer","prettier","path","packagePath","resolve","existsSync","logError","exit","bump","type","Promise","prompt","choices","name","then","retType","vv","from","patch","minor","major","to","end","myFileContent","soPretty","format","printWidth","tabWidth","singleQuote","trailingComma","bracketSpacing","semi","useTabs","parser","jsxBracketSameLine","e","info","chalk","boxen","ONE_SIXTH","ONE_THIRD","TWO_THIRDS","utils","emptyDir","f","err","error","desiredMode","defaultOptions","mode","ensureDir","directory","ensureFile","pathExists","exists","readJson","packageObj","readFile","fl","removeFile","remove","writeFile","contents","outputFile","writeJson","json","chainAsync","fns","curr","last","length","next","fn","appendToFile","appendFileSync","boxInform","msg","secondary","padding","margin","left","top","bottom","right","hex","bold","underline","borderStyle","topLeft","topRight","bottomLeft","bottomRight","horizontal","vertical","align","hue2rgb","p","q","t","hsl2rgb","h","s","l","fill","rainbowGradient","len","saturation","lightness","gradient","x","map","c","Math","round","projectDir","join","gen","mdfile","init","scriptName","JoyCon","joyRead","stopDir","dirname","flattenObject","obj","prefix","reduce","acc","k","pre","assign","marked","mdContent","js","lexer","listMe","tempItem","currentCategory","currentTask","taskOrder","item","indx","depth","text","tasks","description","descriptor","order","code","allTasks","categories","catName","ts","tasksArr","tn","parseScriptFile","filepath","data","loadSync","newContent","split","toc","generateToc","warn","red","green","newFile","tocSplit","content","trim","childProcess","message","logInfo","blue","logSuccess","global","ignorePkgs","upgradePackages","upgraded","before","after","element","packagesList","command","pkk","execSync","stdio","env","FORCE_COLOR","PATH","packageJsonAfter","packagesListAfter","moment","spawn","task","quiet","bgHex","rest","on","runCLICommand","runSequence","FcScripts","taskName","taskIndex","findIndex","params","shift","runParallel","separator","convertBold","reg","boldMatches","m","redBright","regunderline","underlineMatches","greenBright","taskList","recentTasks","choiceCategories","cat","category","sepInd","chosenInd","taskToRun","categoryName","catObj","taskNames","projectPath","packageFile","Conf","config","parsePackageFile","taskListAutoComplete","answer","startScripts","clear","get","recentTaskOptions","lastExecuted","reverse","calendar","undefined","Date","now","set","startPackageScripts","packageScripts","clearRecent","optionList","choiceMessage","black","gray","cyan","simple","newBranch","checkoutLocalBranch","pub","branchname","validateNotInDev","git","__dirname","status","current","resolve1","setTimeout","CryptoJS","scriptsDir","rootDir","igPath","encrypt","encryptedFiles","pass","encryptedFile","decryptedFile","willEncrypt","sure","toEncrypt","ciphertext","AES","toString","encryptedFileLocation","decryptedFileLocation","toDecrypt","bytes","decrypt","decryptedData","enc","Utf8","dim","getPass","ignore","ignoredFiles","fscripts","filesToAdd","file","fileSplit","pop","mask","encryptDecrypt","generateFScripts","rgb","textDescription","usage","yargs","example","_","runCommand","choice"],"mappings":"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","file":"index.js","sourceRoot":"..","sourcesContent":["#!/usr/bin/env node\nconst sortObjectKeys = require(\"sort-object-keys\");\nconst detectIndent = require(\"detect-indent\");\n\nconst sortOrder = [\n    \"name\",\n    \"version\",\n    \"description\",\n    \"keywords\",\n    \"sideEffects\",\n    \"main\",\n    \"umd:main\",\n    \"unpkg\",\n    \"module\",\n    \"workspaces\",\n    \"scripts\",\n    \"betterScripts\",\n    \"fscripts\",\n    \"source\",\n    \"jsnext:main\",\n    \"browser\",\n    \"homepage\",\n    \"bugs\",\n    \"repository\",\n    \"private\",\n    \"license\",\n    \"author\",\n    \"contributors\",\n    \"files\",\n    \"types\",\n    \"typings\",\n    \"style\",\n    \"example\",\n    \"examplestyle\",\n    \"assets\",\n    \"bin\",\n    \"man\",\n    \"directories\",\n    \"husky\",\n    \"pre-commit\",\n    \"commitlint\",\n    \"lint-staged\",\n    \"config\",\n    \"nodemonConfig\",\n    \"browserify\",\n    \"babel\",\n    \"browserslist\",\n    \"xo\",\n    \"prettier\",\n    \"eslintConfig\",\n    \"eslintIgnore\",\n    \"stylelint\",\n    \"jest\",\n    \"dependencies\",\n    \"devDependencies\",\n    \"peerDependencies\",\n    \"bundledDependencies\",\n    \"bundleDependencies\",\n    \"optionalDependencies\",\n    \"flat\",\n    \"resolutions\",\n    \"engines\",\n    \"engineStrict\",\n    \"os\",\n    \"cpu\",\n    \"preferGlobal\",\n    \"publishConfig\"\n];\n// See https://docs.npmjs.com/misc/scripts\nconst defaultNpmScripts = [\n    \"install\",\n    \"pack\",\n    \"prepare\",\n    \"publish\",\n    \"restart\",\n    \"shrinkwrap\",\n    \"start\",\n    \"stop\",\n    \"test\",\n    \"uninstall\",\n    \"version\"\n];\n\nfunction sortPackageJson(packageJson, options = {}) {\n    const determinedSortOrder = options.sortOrder || sortOrder;\n    let wasString = false;\n    let hasWindowsNewlines = false;\n    let endCharacters = \"\";\n    let indentLevel = 2;\n    if (typeof packageJson === \"string\") {\n        wasString = true;\n        indentLevel = detectIndent(packageJson).indent;\n        if (packageJson.substr(-1) === \"\\n\") {\n            endCharacters = \"\\n\";\n        }\n        const newlineMatch = packageJson.match(/(\\r?\\n)/);\n        hasWindowsNewlines = (newlineMatch && newlineMatch[0]) === \"\\r\\n\";\n        packageJson = JSON.parse(packageJson);\n    }\n\n    const prefixedScriptRegex = /^(pre|post)(.)/;\n    const prefixableScripts = defaultNpmScripts.slice();\n    if (typeof packageJson.scripts === \"object\") {\n        Object.keys(packageJson.scripts).forEach(script => {\n            const prefixOmitted = script.replace(prefixedScriptRegex, \"$2\");\n            if (packageJson.scripts[prefixOmitted] && !prefixableScripts.includes(prefixOmitted)) {\n                prefixableScripts.push(prefixOmitted);\n            }\n        });\n    }\n\n    function sortSubKey(key, sortList, unique) {\n        if (Array.isArray(packageJson[key])) {\n            packageJson[key] = packageJson[key].sort();\n            if (unique) {\n                packageJson[key] = array_unique(packageJson[key]);\n            }\n            return;\n        }\n        if (typeof packageJson[key] === \"object\") {\n            packageJson[key] = sortObjectKeys(packageJson[key], sortList);\n        }\n    }\n    function toSortKey(script) {\n        const prefixOmitted = script.replace(prefixedScriptRegex, \"$2\");\n        if (prefixableScripts.includes(prefixOmitted)) {\n            return prefixOmitted;\n        }\n        return script;\n    }\n    /*             b\n     *       pre | * | post\n     *   pre  0  | - |  -\n     * a  *   +  | 0 |  -\n     *   post +  | + |  0\n     */\n    function compareScriptKeys(a, b) {\n        if (a === b) return 0;\n        const aScript = toSortKey(a);\n        const bScript = toSortKey(b);\n        if (aScript === bScript) {\n            // pre* is always smaller; post* is always bigger\n            // Covers: pre* vs. *; pre* vs. post*; * vs. post*\n            if (a === `pre${aScript}` || b === `post${bScript}`) return -1;\n            // The rest is bigger: * vs. *pre; *post vs. *pre; *post vs. *\n            return 1;\n        }\n        return aScript < bScript ? -1 : 1;\n    }\n    function array_unique(array) {\n        return array.filter((el, index, arr) => index == arr.indexOf(el));\n    }\n    sortSubKey(\"keywords\", null, true);\n    sortSubKey(\"homepage\");\n    sortSubKey(\"bugs\", [\"url\", \"email\"]);\n    sortSubKey(\"license\", [\"type\", \"url\"]);\n    sortSubKey(\"author\", [\"name\", \"email\", \"url\"]);\n    sortSubKey(\"bin\");\n    sortSubKey(\"man\");\n    sortSubKey(\"directories\", [\"lib\", \"bin\", \"man\", \"doc\", \"example\"]);\n    sortSubKey(\"repository\", [\"type\", \"url\"]);\n    sortSubKey(\"scripts\", compareScriptKeys);\n    sortSubKey(\"betterScripts\", compareScriptKeys);\n    sortSubKey(\"commitlint\");\n    sortSubKey(\"lint-staged\");\n    sortSubKey(\"config\");\n    sortSubKey(\"nodemonConfig\");\n    sortSubKey(\"browserify\");\n    sortSubKey(\"babel\");\n    sortSubKey(\"eslintConfig\");\n    sortSubKey(\"jest\");\n    sortSubKey(\"xo\");\n    sortSubKey(\"prettier\");\n    sortSubKey(\"dependencies\");\n    sortSubKey(\"devDependencies\");\n    sortSubKey(\"peerDependencies\");\n    sortSubKey(\"bundledDependencies\");\n    sortSubKey(\"bundleDependencies\");\n    sortSubKey(\"optionalDependencies\");\n    sortSubKey(\"resolutions\");\n    sortSubKey(\"engines\");\n    sortSubKey(\"engineStrict\");\n    sortSubKey(\"os\");\n    sortSubKey(\"cpu\");\n    sortSubKey(\"preferGlobal\");\n    sortSubKey(\"private\");\n    sortSubKey(\"publishConfig\");\n    packageJson = sortObjectKeys(packageJson, determinedSortOrder);\n    if (wasString) {\n        let result = JSON.stringify(packageJson, null, indentLevel) + endCharacters;\n        if (hasWindowsNewlines) {\n            result = result.replace(/\\n/g, \"\\r\\n\");\n        }\n        return result;\n    }\n    return packageJson;\n}\nmodule.exports = sortPackageJson;\nmodule.exports.sortPackageJson = sortPackageJson;\nmodule.exports.sortOrder = sortOrder;\n\nif (require.main === module) {\n    const fs = require(\"fs\");\n\n    const filesToProcess = process.argv[2]\n        ? process.argv.slice(2)\n        : [`${process.cwd()}/package.json`];\n\n    filesToProcess.forEach(filePath => {\n        const packageJson = fs.readFileSync(filePath, \"utf8\");\n        const sorted = sortPackageJson(packageJson);\n        if (sorted !== packageJson) {\n            fs.writeFileSync(filePath, sorted, \"utf8\");\n            console.log(`${filePath} is sorted!`);\n        }\n    });\n}\n","const versiony = require(\"versiony\");\nconst inquirer = require(\"inquirer\");\nconst prettier = require(\"prettier\");\nconst path = require(\"path\");\nconst fs = require(\"fs\");\nconst sortPackageJson = require(\"./sort.js\");\nlet packagePath = path.resolve(process.cwd(), \"package.json\");\n\nif (!fs.existsSync(packagePath)) {\n    logError(\"Cannot find package.json file in the current directory\");\n    process.exit(1);\n}\n\nconst bump = async () => {\n    const type = await new Promise(resolve => {\n        inquirer\n            .prompt([\n                {\n                    type: \"list\",\n                    choices: [\"patch\", \"minor\", \"major\"],\n                    name: \"retType\"\n                }\n            ])\n            .then(async ({ retType }) => {\n                resolve(retType);\n            });\n    });\n\n    const vv = versiony.from(packagePath);\n    if (type === \"patch\") vv.patch();\n    if (type === \"minor\") vv.minor().patch(0);\n    if (type === \"major\") {\n        vv.major()\n            .patch(0)\n            .minor(0);\n    }\n    vv.to(packagePath).end();\n    let myFileContent = await fs.readFileSync(packagePath, \"utf8\");\n    let soPretty = \"\";\n    myFileContent = JSON.stringify(sortPackageJson(JSON.parse(myFileContent)));\n    try {\n        soPretty = prettier.format(myFileContent, {\n            printWidth: 20,\n            tabWidth: 4,\n            singleQuote: false,\n            trailingComma: \"none\",\n            bracketSpacing: true,\n            semi: true,\n            useTabs: true,\n            parser: \"json\",\n            jsxBracketSameLine: false // parser: \"json\",\n        });\n    } catch (e) {\n        console.info(\"-- Console ERR\", e);\n    }\n    await fs.writeFileSync(packagePath, soPretty, \"utf8\");\n};\n\nmodule.exports = bump;\n","const fs = require(\"fs-extra\");\nconst chalk = require(\"chalk\");\nconst boxen = require(\"boxen\");\nconst ONE_SIXTH = 1 / 6;\nconst ONE_THIRD = 1 / 3;\nconst TWO_THIRDS = 2 / 3;\nconst utils = {};\n\n/**\n * Output json file\n * @param f - file name with directory\n * @return {boolean}\n * @example\n const file = \"/tmp/this/path/does/not/exist/file.json\";\n removeFile(file);\n */\nutils.emptyDir = async f => {\n    try {\n        await fs.emptyDir(f);\n        // console.log(`${chalk.green.underline(\"Directory\")} ${chalk.bold(f)} emptied!`);\n    } catch (err) {\n        console.error(err);\n    }\n};\n\nconst desiredMode = 0o2775;\nconst defaultOptions = {\n    mode: desiredMode\n};\nutils.ensureDir = async (directory, options = defaultOptions) => {\n    try {\n        await fs.ensureDir(directory, options);\n    } catch (err) {\n        console.error(err);\n    }\n};\n\nutils.ensureFile = async f => {\n    try {\n        await fs.ensureFile(f);\n    } catch (err) {\n        console.error(err);\n    }\n};\n\n/**\n * Ensure path exists with dirs\n * @param f the file path\n * @return {boolean}\n * @example\n const file = \".fsr/config.json\";\n pathExists(file);\n */\nutils.pathExists = async f => {\n    const exists = await fs.pathExists(f);\n\n    return exists;\n};\n\n/**\n * Read json file\n * @param f - file name with directory\n * @return {Promise<void>}\n * @example\n const file = \"/tmp/this/path/does/not/exist/file.json\";\n outputJson(file);\n */\nutils.readJson = async f => {\n    try {\n        const packageObj = await fs.readJson(f);\n        // console.log(`${chalk.green.underline(\"File\")} ${chalk.bold(f)} read!`);\n        return packageObj;\n    } catch (err) {\n        console.error(err);\n        return {};\n    }\n};\n\nutils.readFile = async f => {\n    try {\n        let fl = await fs.readFileSync(f, \"utf8\");\n        return fl;\n    } catch (err) {\n        console.error(err);\n        return {};\n    }\n};\n\nutils.removeFile = async f => {\n    try {\n        // console.log(`${chalk.green.underline(\"File\")} ${chalk.bold(f)} removed!`);\n        return await fs.remove(f);\n    } catch (err) {\n        console.error(`File ${f} NOT REMOVED! ${err}`);\n        return false;\n    }\n};\n\n/**\n * Write file\n * @param f - file name with directory\n * @param contents - text inside the file\n * @return {Promise<void>}\n * @example\n const file = \"/tmp/this/path/does/not/exist/file.json\";\n writeFile(file);\n */\nutils.writeFile = async (f, contents = \"\") => {\n    try {\n        return await fs.outputFile(f, contents);\n        // console.log(`${chalk.green.underline(\"File\")} ${chalk.bold(f)} written!`);\n    } catch (err) {\n        console.error(err);\n    }\n};\n\nutils.writeJson = async (f, json = {}) => {\n    try {\n        await fs.writeJson(f, json);\n        // console.log(`${chalk.green.underline(\"File\")} ${chalk.bold(f)} written!`);\n    } catch (err) {\n        console.error(err);\n    }\n};\n\nutils.chainAsync = fns => {\n    let curr = 0;\n    const last = fns[fns.length - 1];\n    const next = () => {\n        const fn = fns[curr++];\n        fn === last ? fn() : fn(next);\n    };\n    next();\n};\n\nutils.appendToFile = async (f, contents = \"\") => {\n    try {\n        await fs.appendFileSync(f, contents);\n    } catch (err) {\n        console.error(err);\n    }\n};\n\nutils.boxInform = async (\n    msg,\n    secondary = \"\",\n    padding = 0,\n    margin = { left: 2, top: 0, bottom: 0, right: 0 }\n) => {\n    console.log(\n        boxen(\n            chalk.hex(\"#717877\")(msg) +\n                \"\\n\" +\n                chalk.bold.underline.hex(\"#438b34\")(secondary) +\n                chalk.hex(\"#717877\")(\" \"),\n            {\n                padding,\n                margin,\n                borderStyle: {\n                    topLeft: chalk.hex(\"#5a596d\")(\"╔\"),\n                    topRight: chalk.hex(\"#5a596d\")(\"╗\"),\n                    bottomLeft: chalk.hex(\"#5a596d\")(\"╚\"),\n                    bottomRight: chalk.hex(\"#5a596d\")(\"╝\"),\n                    horizontal: chalk.hex(\"#5a596d\")(\"═\"),\n                    vertical: chalk.hex(\"#5a596d\")(\"║\")\n                }, //\"round\",\n                align: \"center\" //,\n            }\n        )\n    );\n};\n\nconst hue2rgb = (p, q, t) => {\n    if (t < 0) {\n        t += 1;\n    }\n    if (t > 1) {\n        t -= 1;\n    }\n    if (t < ONE_SIXTH) {\n        return p + (q - p) * 6 * t;\n    }\n    if (t < 0.5) {\n        return q;\n    }\n    if (t < TWO_THIRDS) {\n        return p + (q - p) * (TWO_THIRDS - t) * 6;\n    }\n    return p;\n};\n\nconst hsl2rgb = (h, s, l) => {\n    if (s === 0) {\n        return new Array(3).fill(l);\n    }\n    const q = l < 0.5 ? l * s + l : l + s - l * s;\n    const p = 2 * l - q;\n    return [hue2rgb(p, q, h + ONE_THIRD), hue2rgb(p, q, h), hue2rgb(p, q, h - ONE_THIRD)];\n};\n\nutils.rainbowGradient = (len, saturation = 1, lightness = 0.5) => {\n    const gradient = [];\n    for (let x = 0; x < len; x++) {\n        gradient.push(hsl2rgb(x / len, saturation, lightness).map(c => Math.round(c * 255)));\n    }\n    return gradient;\n};\n\n// utils.emptyDir = async () => {};\nmodule.exports = utils;\n","const chalk = require(\"chalk\");\nconst inquirer = require(\"inquirer\");\n\nconst { appendToFile, writeFile, boxInform, readJson, readFile } = require(\"./helpers.js\");\nconst path = require(\"path\");\nconst projectDir = process.cwd();\nconst packagePath = path.join(projectDir, \"package.json\");\n\nconst gen = { scripts: [] };\nlet mdfile = `# First category of scripts\n\nWelcome to your new amazing fscripts.md file. It replaces the headaches of npm scripts! But so much more.\n`;\n\ngen.init = async () => {\n    try {\n        gen.packageJson = await readJson(packagePath);\n        Object.keys(gen.packageJson.scripts).forEach(scriptName => {\n            mdfile += `\\n## ${scriptName}\\n\\n${\n                gen.packageJson.scripts[scriptName]\n            }\\n\\n\\`\\`\\`bash\\n${gen.packageJson.scripts[scriptName]}\\n\\`\\`\\`\\n\\n`;\n        });\n        await writeFile(\"./sample.fscripts.md\", mdfile);\n    } catch (err) {\n        console.error(err);\n    }\n};\n\nmodule.exports = gen.init;\n","\"use strict\";\nconst JoyCon = require(\"joycon\");\nconst path = require(\"path\");\nconst chalk = require(\"chalk\");\n\nconst joyRead = new JoyCon({\n    // Stop reading at parent dir\n    // i.e. Only read file from process.cwd()\n    stopDir: path.dirname(process.cwd())\n});\nconst flattenObject = (obj, prefix = \"\") =>\n    Object.keys(obj).reduce((acc, k) => {\n        const pre = prefix.length ? prefix + \".\" : \"\";\n        if (typeof obj[k] === \"object\") Object.assign(acc, flattenObject(obj[k], pre + k));\n        else acc[pre + k] = obj[k];\n        return acc;\n    }, {});\n\nconst marked = require(\"marked\");\n\nlet parse = function(mdContent) {\n    let js = marked.lexer(mdContent);\n    js = js.filter(e => e.type !== \"space\");\n\n    // let firstHeading = js.findIndex(e => e.type === \"heading\" && e.depth === 1); //?\n    let listMe = js.slice();\n    let tempItem = {};\n    let currentCategory = \"\";\n    let currentTask = \"\";\n    let taskOrder = 0;\n    listMe.forEach((item, indx) => {\n        if (item.type === \"heading\" && item.depth === 1) {\n            taskOrder = 0;\n            currentCategory = item.text;\n            tempItem[currentCategory] = { name: item.text, tasks: {}, description: \"\" };\n            let descriptor = js[indx + 1];\n            if (descriptor.type === \"paragraph\") {\n                tempItem[currentCategory].description = descriptor.text;\n            }\n        } else if (item.type === \"heading\" && item.depth === 2) {\n            currentTask = item.text;\n            tempItem[currentCategory].tasks[currentTask] = {\n                script: \"\",\n                name: currentTask,\n                description: \"\",\n                order: taskOrder\n            };\n            taskOrder++;\n            let descriptor = js[indx + 1];\n            let code = js[indx + 2];\n            if (descriptor.type === \"paragraph\" && code.type === \"code\") {\n                tempItem[currentCategory].tasks[currentTask].description = descriptor.text;\n                tempItem[currentCategory].tasks[currentTask].script = code.text;\n            } else if (descriptor.type === \"code\") {\n                tempItem[currentCategory].tasks[currentTask].script = descriptor.text;\n            }\n        }\n    });\n    let allTasks = [];\n    let categories = Object.keys(tempItem).map(catName => {\n        let ts = tempItem[catName].tasks;\n        let tasksArr = Object.keys(ts).map(tn => ts[tn]);\n        allTasks = [...allTasks, ...tasksArr];\n        return { name: catName, ...tempItem[catName] };\n    });\n    return { categories, allTasks };\n};\nconst parseScriptFile = async () => {\n    const { path: filepath, data } = joyRead.loadSync([\"fscripts.md\"]);\n    if (!filepath) {\n        //         console.warn(\n        //             `${chalk.bold.red(\"You're missing the fscripts.md file!\")}\n        // ${chalk.green(\"Please run 'fsr generate' to get started!\")}`\n        //         );\n        //\n        //         process.exit(0);\n        //         return null;\n        return false;\n    } else {\n        // console.warn(`${chalk.bold.green(\"Located fscripts.md file!\")}`);\n        let newContent = data.split(\"<!-- end toc -->\");\n        newContent = newContent[newContent.length === 2 ? 1 : 0];\n        return parse(newContent);\n    }\n};\n\nmodule.exports = parseScriptFile;\n","const path = require(\"path\");\nconst chalk = require(\"chalk\");\nrequire(\"markdown-toc\");\nconst JoyCon = require(\"joycon\");\nconst toc = require(\"markdown-toc\");\n\nconst joyRead = new JoyCon({\n    // Stop reading at parent dir\n    // i.e. Only read file from process.cwd()\n    stopDir: path.dirname(process.cwd())\n});\nconst { writeFile } = require(\"./helpers.js\");\n// const projectDir = process.cwd();\n\nconst generateToc = async () => {\n    const { path: filepath, data } = joyRead.loadSync([\"fscripts.md\"]);\n    if (!filepath) {\n        console.warn(\n            `${chalk.bold.red(\"You're missing the fscripts.md file!\")}\n${chalk.green(\"Please run 'fsr generate' to get started!\")}`\n        );\n        process.exit(0);\n        return null;\n    } else {\n        console.warn(`${chalk.bold.green(\"Located fscripts.md file!\")}`);\n        let newFile = ``;\n        let tocSplit = data.split(\"<!-- end toc -->\");\n        if (tocSplit.length === 2) {\n            newFile = toc(tocSplit[1]).content + \"\\n<!-- end toc -->\\n\\n\" + tocSplit[1].trim();\n        } else {\n            newFile = toc(data).content + \"\\n<!-- end toc -->\\n\\n\" + data.trim();\n        }\n        await writeFile(\"./fscripts.md\", newFile);\n    }\n};\n\nmodule.exports = generateToc;\n","#!/usr/bin/env node\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst childProcess = require(\"child_process\");\nconst chalk = require(\"chalk\");\nconst logError = message => {\n    console.log(chalk.red(\"[Error]: \" + message));\n};\nconst logInfo = message => {\n    console.log(chalk.blue(\"[Start]: \" + message));\n};\nconst logSuccess = message => {\n    console.log(chalk.green(\"[Done]: \" + message));\n};\n\nlet global = \"\";\nlet packagePath = path.resolve(process.cwd(), \"package.json\");\n\nif (!fs.existsSync(packagePath)) {\n    logError(\"Cannot find package.json file in the current directory\");\n    process.exit(1);\n}\n\nconst packageJson = require(packagePath);\nlet ignorePkgs = [];\nconst upgradePackages = async () => {\n    if (packageJson[\"fscripts\"]) {\n        if (packageJson[\"fscripts\"][\"ignore-upgrade\"]) {\n            ignorePkgs = packageJson[\"fscripts\"][\"ignore-upgrade\"];\n        }\n    }\n    let upgraded = { before: {}, after: {} };\n    for (let element of [\"dependencies\", \"devDependencies\", \"peerDependencies\"]) {\n        if (packageJson[element]) {\n            const packages = Object.keys(packageJson[element]);\n            let packagesList = packages\n                .filter(pkk => !ignorePkgs.includes(pkk))\n                .map(pkk => {\n                    upgraded[\"before\"][pkk] = packageJson[element][pkk];\n                    return pkk + \"@latest\";\n                })\n                .join(\" \");\n            let command = `yarn add ${packagesList}`;\n            try {\n                // logInfo(command);\n                childProcess.execSync(command, {\n                    stdio: \"inherit\",\n                    env: Object.assign({}, process.env, {\n                        FORCE_COLOR: true,\n                        PATH: `${path.resolve(\"node_modules\")}:${process.env.PATH}`\n                    })\n                });\n                const packageJsonAfter = JSON.parse(fs.readFileSync(packagePath));\n                const packagesAfter = Object.keys(packageJsonAfter[element]);\n                let packagesListAfter = packagesAfter\n                    .filter(pkk => !ignorePkgs.includes(pkk))\n                    .map(pkk => {\n                        upgraded[\"after\"][pkk] = packageJsonAfter[element][pkk];\n                        return upgraded[\"before\"][pkk] !== upgraded[\"after\"][pkk]\n                            ? `Updated: ${pkk} from: ${upgraded[\"before\"][pkk]} | to: ${\n                                  upgraded[\"after\"][pkk]\n                              }\\n`\n                            : ``;\n                    })\n                    .join(\"\");\n                logSuccess(packagesListAfter);\n            } catch (e) {\n                logError(`${command} - ${e}`);\n            }\n        }\n    }\n};\nmodule.exports = upgradePackages;\n","const chalk = require(\"chalk\");\nconst path = require(\"path\");\nconst moment = require(\"moment\");\nconst spawn = require(\"cross-spawn\");\n\nmodule.exports = async ({ script, task, type = script.type }, quiet = false) => {\n    if (!quiet) {\n        console.log(\n            `${chalk.green\n                .bgHex(\"#181c24\")\n                .bold(\"[\" + moment().format(\"HH:MM:SS\") + \"]\")}${chalk\n                .bgHex(\"#181c24\")\n                .bold.hex(\"#8c91a7\")(\" \" + task.name + \": \")}`\n        );\n    }\n    return new Promise(resolve => {\n        const cmd = spawn(type, [...script.rest], {\n            stdio: \"inherit\",\n            env: Object.assign({}, process.env, {\n                FORCE_COLOR: true,\n                PATH: `${path.resolve(\"node_modules/.bin\")}:${process.env.PATH}`\n            })\n        });\n\n        cmd.on(\"close\", code => {\n            if (code === 0) {\n                resolve();\n            } else {\n                console.error(`${chalk.red(\"ERROR\")} ${code}`);\n            }\n        });\n    });\n};\n","const runCLICommand = require(\"./runCLICommand\");\nconst chalk = require(\"chalk\");\n\nconst runSequence = async (tasks, FcScripts) => {\n    for (let t in tasks) {\n        let taskName = tasks[t];\n        let taskIndex = FcScripts.allTasks.findIndex(t => t.name === taskName);\n        if (taskIndex === -1) {\n            console.log(\n                `${chalk.red.underline(\n                    \"Skipping task \" + taskName + \", as it cannot be found in .md file\"\n                )}`\n            );\n        } else {\n            let script = FcScripts.allTasks[taskIndex].script;\n            let params = script.split(\" \");\n            let type = params.shift();\n            await runCLICommand({\n                task: { name: taskName },\n                script: {\n                    type: type,\n                    rest: params\n                }\n            });\n        }\n    }\n};\n\nmodule.exports = runSequence;\n// (async () => {\n//     await startScripts();\n// })();\n","const runCLICommand = require(\"./runCLICommand\");\n\nconst runParallel = async (tasks, FcScripts) => {\n    for (let t in tasks) {\n        let taskName = tasks[t];\n        let taskIndex = FcScripts.allTasks.findIndex(t => t.name === taskName);\n        let script = FcScripts.allTasks[taskIndex].script;\n        let params = script.split(\" \");\n        let type = params.shift();\n\n        runCLICommand({\n            task: { name: taskName },\n            script: {\n                type: type,\n                rest: params\n            }\n        });\n    }\n};\n\nmodule.exports = runParallel;\n","const inquirer = require(\"inquirer\");\nconst separator = \"   ~   \";\nconst chalk = require(\"chalk\");\nconst convertBold = arr => {\n    return arr.map(e => {\n        let reg = /(\\*\\*|^\\*\\*)(?=\\S)([\\s\\S]*?\\S)\\*\\*(?![\\*\\*\\S])/g;\n        let boldMatches = e.match(reg);\n        if (boldMatches !== null) {\n            boldMatches.forEach(m => {\n                e = e.replace(m, chalk.bold.redBright(m.replace(/\\*\\*/g, \" \"))); //.underline.bgBlack.whiteBright\n            });\n        }\n        let regunderline = /(_|^_)(?=\\S)([\\s\\S]*?\\S)_(?![_\\S])/g;\n        let underlineMatches = e.match(regunderline);\n        if (underlineMatches !== null) {\n            underlineMatches.forEach(m => {\n                e = e.replace(m, chalk.underline.greenBright(m.replace(/\\_\\_/g, \" \"))); //.underline.bgBlack.whiteBright\n            });\n        }\n        return e;\n    });\n};\nconst taskList = async (FcScripts, recentTasks) => {\n    return new Promise(resolve => {\n        let choiceCategories = [\n            ...recentTasks,\n            ...[\"-------------\"],\n            ...FcScripts.categories.map(cat => {\n                return cat.name + separator + cat.description;\n            })\n        ];\n        choiceCategories = convertBold(choiceCategories);\n        inquirer\n        .prompt([\n            {\n                type: \"list\",\n                name: \"category\",\n                message: \"What category do you want to run?\",\n                choices: choiceCategories\n            }\n        ])\n        .then(({ category }) => {\n            let sepInd = choiceCategories.indexOf(\"-------------\");\n            let chosenInd = choiceCategories.indexOf(category);\n            if (sepInd === chosenInd) {\n                console.log(\"Can't select divider\");\n            } else if (chosenInd < sepInd) {\n                let taskToRun = category.split(separator)[0].trim();\n                resolve(taskToRun);\n            } else {\n                let categoryName = category.split(separator)[0];\n                let catObj = FcScripts.categories.findIndex(e => e.name === categoryName);\n                catObj = FcScripts.categories[catObj];\n                let taskNames = Object.keys(catObj.tasks).map(taskName => {\n                    let task = catObj.tasks[taskName];\n                    return `${taskName} ${\n                        task.description\n                            ? separator + task.description.replace(/\\n/g, \" \").trim()\n                            : \"\"\n                    }`;\n                });\n                taskNames = convertBold(taskNames);\n                inquirer\n                .prompt([\n                    {\n                        type: \"list\",\n                        name: \"taskToRun\",\n                        message: \"Which task do you want to run\",\n                        choices: taskNames\n                    }\n                ])\n                .then(({ taskToRun }) => {\n                    taskToRun = taskToRun.split(separator)[0].trim();\n                    resolve(taskToRun);\n                });\n            }\n        });\n    });\n};\n\nmodule.exports = taskList;\n","\"use strict\";\nconst path = require(\"path\");\nconst chalk = require(\"chalk\");\nconst projectPath = path.join(process.cwd(), \"./package.json\");\nconst { readJson } = require(\"./helpers\");\nconst parseScriptFile = async () => {\n    const packageFile = await readJson(projectPath);\n    return packageFile.scripts;\n};\n\nmodule.exports = parseScriptFile;\n","const taskList = require(\"./taskList\");\nconst separator = \"   ~   \";\nconst Conf = require(\"conf\");\nconst config = new Conf();\nconst moment = require(\"moment\");\nconst chalk = require(\"chalk\");\nconst parseScriptFile = require(\"./parseScriptsMd.js\");\nconst parsePackageFile = require(\"./parseScriptsPackage.js\");\nconst runCLICommand = require(\"./runCLICommand\");\nconst { prompt } = require(\"enquirer\");\n\nconst taskListAutoComplete = async tasks => {\n    try {\n        let { answer } = await prompt({\n            type: \"autocomplete\",\n            message: `${chalk.green.bold.underline(\"Choose task to run\")}`,\n            choices: tasks,\n            name: `answer`\n        });\n        return answer.split(separator)[0].trim();\n    } catch (e) {\n        return false;\n    }\n};\n\nconst startScripts = async (categories = true) => {\n    console.clear();\n    const FcScripts = await parseScriptFile();\n    if (FcScripts === false) {\n        return false;\n    }\n    let recentTasks = config.get(\"recentTasks\", {});\n    let recentTaskArr = Object.keys(recentTasks)\n        .map(taskName => {\n            let task = recentTasks[taskName];\n            return { name: taskName, lastExecuted: task.lastExecuted };\n        })\n        .sort((a, b) =>\n            a.lastExecuted > b.lastExecuted ? 1 : b.lastExecuted > a.lastExecuted ? -1 : 0\n        )\n        .reverse()\n        .slice(0, 3);\n    let recentTaskOptions = recentTaskArr.map(task => {\n        return task.name + separator + moment(task.lastExecuted).calendar();\n    });\n    let taskToRun;\n    if (categories) {\n        taskToRun = await taskList(FcScripts, recentTaskOptions);\n    } else {\n        let tasks = FcScripts.allTasks;\n\n        taskToRun = await taskListAutoComplete(\n            tasks.map(task => {\n                return `${task.name}${separator}${task.description}`;\n            })\n        );\n    }\n    if (recentTasks[taskToRun] === undefined) {\n        recentTasks[taskToRun] = { lastExecuted: Date.now() };\n    } else {\n        recentTasks[taskToRun].lastExecuted = Date.now();\n    }\n    config.set(\"recentTasks\", recentTasks);\n    let taskIndex = FcScripts.allTasks.findIndex(t => t.name === taskToRun);\n    let script = FcScripts.allTasks[taskIndex].script;\n    let params = script.split(\" \");\n    let type = params.shift();\n    await runCLICommand({\n        task: { name: taskToRun },\n        script: {\n            type: type,\n            rest: params\n        }\n    });\n};\n\nconst startPackageScripts = async () => {\n    console.clear();\n    const packageScripts = await parsePackageFile();\n    let tasks = Object.keys(packageScripts).map(e => {\n        return { name: e, script: packageScripts[e] };\n    });\n\n    let taskToRun = await taskListAutoComplete(\n        tasks.map(task => {\n            return `${task.name}${separator}${task.script}`;\n        })\n    );\n    if (taskToRun === false) {\n        console.log(chalk.green.bold(\"See you soon!\"));\n        return false;\n    }\n    await runCLICommand({\n        task: { name: taskToRun },\n        script: {\n            type: \"yarn\",\n            rest: [taskToRun]\n        }\n    });\n};\n\nconst clearRecent = async () => {\n    config.set(\"recentTasks\", {});\n};\nmodule.exports = {\n    startScripts,\n    taskListAutoComplete,\n    clearRecent,\n    startPackageScripts\n};\n","const separator = \"   ~   \";\nconst chalk = require(\"chalk\");\n\nconst { prompt } = require(\"enquirer\");\nconst optionList = async () => {\n    let choiceCategories = [\n        {\n            name: \"start\",\n            message: \"Choose category then task to run\"\n        },\n        {\n            name: \"list\",\n            message: \"Select any task with text autocompletion\"\n        },\n        {\n            name: \"scripts\",\n            message: \"Choose a script from package.json\"\n        },\n        {\n            name: \"upgrade\",\n            message: \"Upgrade all your packages except ones specified by 'ignore-upgrade':[]\"\n        },\n        {\n            name: \"bump\",\n            message: \"Bump package.json and beautify it!\"\n        },\n        {\n            name: \"encryption\",\n            message: \"Encrypt/Decrypt secret files\"\n        },\n        {\n            name: \"clear\",\n            message: \"Clear recent task history\"\n        },\n        {\n            name: \"generate\",\n            message: \"Generate a sample fscripts.md file from the package.json\"\n        },\n        {\n            name: \"toc\",\n            message: \"Generate updated Table of Contents on top of the fscripts.md file\"\n        },\n        {\n            name: \"--help\",\n            message: \"See full help documentation\"\n        }\n    ];\n    try {\n        let { answer } = await prompt({\n            type: \"select\",\n            name: `answer`,\n            choiceMessage: e => {\n                // return JSON.stringify(e)\n                // return e.message;\n                return chalk.bold.underline.black(e.name + \":\" + chalk.gray(\" \" + e.message));\n            },\n            message: `${chalk.cyan.bold.underline(\"Whatz category do you want to run?\")}`,\n            choices: choiceCategories\n        });\n        return answer;\n    } catch (e) {\n        return false;\n    }\n};\n\nmodule.exports = optionList;\n","const inquirer = require(\"inquirer\");\nconst chalk = require(\"chalk\");\nconst boxen = require(\"boxen\");\n\nconst simple = require(\"simple-git\");\n\nconst newBranch = async name => {\n    await simple().checkoutLocalBranch(name);\n    console.log(boxen(chalk.green(`New branch ${name} created`)));\n};\n\nasync function pub() {\n    return new Promise(resolve => {\n        inquirer\n            .prompt([\n                {\n                    type: \"input\",\n                    message: chalk.bold.hex(\"#38be18\")(`Name new feature branch (or type cancel):`),\n                    name: \"branchname\"\n                }\n            ])\n            .then(async ({ branchname }) => {\n                if (branchname !== \"CatsDontLie\") await newBranch(branchname);\n                resolve();\n            });\n    });\n}\n\nconst validateNotInDev = async () => {\n    await new Promise(async resolve => {\n        const git = require(\"simple-git/promise\");\n\n        let statusSummary = await git(__dirname).status();\n        if (statusSummary.current === \"CatsDontLie\") {\n            console.clear();\n            console.log(\n                boxen(chalk.bold.underline.red(\"DO NO MAKE CHANGES IN DEV!\"), {\n                    padding: 2\n                })\n            );\n            await new Promise(resolve1 =>\n                setTimeout(() => {\n                    resolve1();\n                }, 1000)\n            );\n            await pub();\n            resolve();\n        } else {\n            resolve();\n        }\n    });\n};\nmodule.exports = validateNotInDev;\n","const CryptoJS = require(\"crypto-js\");\nconst chalk = require(\"chalk\");\nvar inquirer = require(\"inquirer\");\n\nconst {\n    appendToFile,\n    ensureFile,\n    writeFile,\n    boxInform,\n    readJson,\n    readFile\n} = require(\"../helpers.js\");\nconst path = require(\"path\");\nconst scriptsDir = process.cwd();\nconst rootDir = path.join(scriptsDir, \"./\");\nconst packagePath = path.join(rootDir, \"package.json\");\nconst igPath = path.join(rootDir, \".gitignore\");\nconst prettier = require(\"prettier\");\nconst encrypt = { encryptedFiles: [] };\n\n// prettier-ignore\nencrypt.encrypt = async (pass, encryptedFile, decryptedFile) => {\n    let willEncrypt = true;\n    let sureSure = await ensureFile(encryptedFile);\n    if (sureSure) {\n        console.log(`${chalk.bold.red(\"FILE ALREADY EXISTS ARE YOU SURE?\")}`);\n        willEncrypt = await new Promise(resolve => {\n            inquirer\n                .prompt([\n                    {\n                        type: \"confirm\",\n                        message: chalk.bold.hex(\"#38be18\")(`Sure? (y/n): `),\n                        name: \"sure\"\n                    }\n                ])\n                .then(({ sure }) => {\n                    resolve(sure);\n                });\n        });\n    }\n    if (willEncrypt) {\n        let toEncrypt = await readFile(decryptedFile);\n        const ciphertext = CryptoJS.AES.encrypt(toEncrypt, pass);\n        await writeFile(encryptedFile, ciphertext.toString());\n    }\n\n};\n// prettier-ignore\nencrypt.decrypt = async (pass, encryptedFileLocation, decryptedFileLocation) => {\n    // let encryptedFileLocation = path.join(rootDir,\".\"+encryptedFile);\n    // let decryptedFileLocation = path.join(rootDir,encryptedFile);\n    let willEncrypt = true;\n    let sureSure = await ensureFile(decryptedFileLocation);\n    if (sureSure) {\n        console.log(`${chalk.bold.red(\"FILE ALREADY EXISTS ARE YOU SURE?\")}`);\n        willEncrypt = await new Promise(resolve => {\n            inquirer\n                .prompt([\n                    {\n                        type: \"confirm\",\n                        message: chalk.bold.hex(\"#38be18\")(`Sure wanna override file ${decryptedFileLocation}? (y/n): `),\n                        name: \"sure\"\n                    }\n                ])\n                .then(({ sure }) => {\n                    resolve(sure);\n                });\n        });\n    }\n    if (willEncrypt) {\n        let toDecrypt = await readFile(encryptedFileLocation);\n        const bytes = CryptoJS.AES.decrypt(toDecrypt, pass);\n        let decryptedData;\n        try {\n            decryptedData = bytes.toString(CryptoJS.enc.Utf8);\n        } catch (e) {\n            console.error(\"-- Console Problem \", e);\n        }\n        await writeFile(decryptedFileLocation, decryptedData);\n        console.warn(`${chalk.bold.green.underline(\"DECRYPTED FILE:\")} ${chalk.bold.dim(path.join(scriptsDir, decryptedFileLocation))}`);\n    }\n\n};\n\nencrypt.init = async () => {\n    try {\n        let pass = await encrypt.getPass();\n        let toEncrypt = await encrypt.toEncrypt();\n        encrypt.packageJson = await readJson(packagePath);\n        encrypt.ignore = await readFile(igPath);\n        encrypt.ignoredFiles = encrypt.ignore.split(\"\\n\");\n        if (encrypt.packageJson.fscripts) {\n            if (encrypt.packageJson.fscripts.encryptedFiles) {\n                encrypt.encryptedFiles = encrypt.packageJson.fscripts.encryptedFiles;\n                let filesToAdd = \"\\n\";\n                for (const e of encrypt.encryptedFiles) {\n                    if (encrypt.ignoredFiles.indexOf(e) === -1) {\n                        filesToAdd += e + \"\\n\";\n                    }\n                    let file = e + \"\";\n                    let fileSplit = file.split(\"/\");\n                    let name = fileSplit.pop();\n                    let encryptedFile = fileSplit.slice();\n                    let decryptedFile = fileSplit.slice();\n                    encryptedFile.push(\".\" + name);\n                    encryptedFile = path.join(rootDir, encryptedFile.join(\"/\"));\n                    decryptedFile.push(name);\n                    decryptedFile = path.join(rootDir, decryptedFile.join(\"/\"));\n\n                    if (toEncrypt) {\n                        await encrypt.encrypt(pass, encryptedFile, decryptedFile);\n                    } else {\n                        await encrypt.decrypt(pass, encryptedFile, decryptedFile);\n                    }\n                }\n\n                if (filesToAdd.trim().length > 0) {\n                    await appendToFile(igPath, filesToAdd + \"\\n\");\n                    boxInform(\" Added files to .gitignore: \", filesToAdd);\n                }\n            }\n        }\n    } catch (err) {\n        console.error(err);\n    }\n};\n\nencrypt.getPass = async () => {\n    return await new Promise(resolve => {\n        inquirer\n            .prompt([\n                {\n                    type: \"password\",\n                    mask: chalk.underline(\" ●\"),\n                    message: chalk.bold.hex(\"#38be18\")(`Enter a SECRET key (same as pass app) : `),\n                    name: \"pass\"\n                }\n            ])\n            .then(({ pass }) => {\n                resolve(pass);\n            });\n    });\n};\nencrypt.toEncrypt = async () => {\n    return await new Promise(resolve => {\n        inquirer\n            .prompt([\n                {\n                    type: \"list\",\n                    message: chalk.bold.hex(\"#38be18\")(\"Which direction?\"),\n                    choices: [\"encrypt\", \"decrypt\"],\n                    name: \"encryptDecrypt\"\n                }\n            ])\n            .then(async ({ encryptDecrypt }) => {\n                resolve(encryptDecrypt === \"encrypt\");\n            });\n    });\n};\n\nmodule.exports = { ...encrypt };\n","#!/usr/bin/env node\nconst bump = require(\"./lib/release/bump.js\");\nconst chalk = require(\"chalk\");\nconst generateFScripts = require(\"./lib/generateFScripts.js\");\nconst parseScriptFile = require(\"./lib/parseScriptsMd.js\");\n// const parseScriptPackage = require(\"./lib/parseScriptsPackage\");\nconst generateToc = require(\"./lib/generateToc\");\nconst upgradePackages = require(\"./lib/upgradePackages\");\nconst runSequence = require(\"./lib/runSequence\");\nconst runParallel = require(\"./lib/runParallel\");\nconst runCLICommand = require(\"./lib/runCLICommand\");\nconst { startPackageScripts, startScripts, clearRecent } = require(\"./lib/startScripts.js\");\nconst taskName = chalk.rgb(39, 173, 96).bold.underline;\nconst textDescription = chalk.rgb(159, 161, 181);\nconst optionList = require(\"./lib/optionList\");\nconst validateNotInDev = require(\"./lib/git/validateNotDev.js\");\nconst encrypt = require(\"./lib/encryption/encryption\");\n\n(async () => {\n    await validateNotInDev();\n\n    const argv = require(\"yargs\")\n        .usage(\"Usage: $0 <command> [options]\")\n\n        /**\n         *  fsr\n         */\n        .command(\"\", \"Choose a script runner command\", yargs => {}, async function() {})\n        .example(`${taskName(\"$0\")}`, `${textDescription(\"Choose a script runner command\")}`)\n\n        /**\n         * fsr\n         * start --\n         */\n        .command(\"start\", \"Choose category then task to run\", yargs => {}, async function() {\n            if ((await startScripts()) === false) {\n                await startPackageScripts();\n            }\n        })\n        .example(`${taskName(\"$0 start\")}`, `${textDescription(\"Open a task selection selector\")}`)\n\n        /**\n         * fsr\n         * scripts --\n         */\n        .command(\"scripts\", \"Choose a script from package.json\", yargs => {}, async function() {\n            await startPackageScripts();\n        })\n        .example(\n            `${taskName(\"$0 scripts\")}`,\n            `${textDescription(\"Choose a script from package.json\")}`\n        )\n\n        /**\n         * fsr\n         * list --\n         */\n        .command(\"list\", \"Select any task with text autocompletion\", () => {}, async function(\n            argv\n        ) {\n            await startScripts(false);\n            // const tasks = await scriptsParsed().allTasks;\n        })\n        .example(`${taskName(\"$0 list\")}`, `${textDescription(\"Show you all tasks you can run\")}`)\n\n        /**\n         * fsr\n         * run --\n         */\n        .command(\"run\", \"Run a specific task\", () => {}, async function(argv) {\n            let task = argv._[1];\n            const FcScripts = await parseScriptFile();\n            let taskIndex = FcScripts.allTasks.findIndex(t => t.name === task);\n            let taskData = FcScripts.allTasks[taskIndex];\n            let runCommand = taskData[\"script\"].split(\" \");\n            let type = runCommand.shift();\n            let params = runCommand.join(\" \");\n            let args = Object.keys(argv)\n                .filter(e => e !== \"_\" && e !== \"$0\")\n                .map(e => ` --${e}=${argv[e]}`);\n            params += \" \" + args.join(\" \");\n            await runCLICommand({\n                task: { name: task },\n                script: {\n                    type: type,\n                    rest: params.split(\" \")\n                }\n            });\n        })\n        .example(`${taskName(\"$0 run start:web\")}`, `${textDescription(\"Run task 'start:web'\")}`)\n\n        /**\n         * fsr\n         * upgrade --\n         */\n        .command(\n            \"upgrade\",\n            \"Upgrade all your packages except ones specified by 'ignore-upgrade':[]\",\n            () => {},\n            async function(argv) {\n                let task = argv._[1];\n                await upgradePackages();\n            }\n        )\n        .example(`${taskName(\"$0 upgrade\")}`, `${textDescription(\"Upgraded!\")}`)\n\n        /**\n         * fsr\n         * bump --\n         */\n        .command(\"bump\", \"Bump package.json and beautify it!\", () => {}, async function(argv) {\n            let task = argv._[1];\n            await bump();\n        })\n        .example(`${taskName(\"$0 bump\")}`, `${textDescription(\"BUMPED AND PRETTY!\")}`)\n\n        /**\n         * fsr\n         * run-s --\n         */\n        .command(\"run-s\", \"Run a set of tasks one after another\", () => {}, async function(argv) {\n            let tasks = argv._.slice();\n            tasks.shift();\n            const FcScripts = await parseScriptFile();\n            await runSequence(tasks, FcScripts);\n        })\n        .example(\n            `${taskName(\"$0 run-s start:web start:desktop\")}`,\n            `${textDescription(\"Run task 'start:web' and afterwards 'start:desktop'\")}`\n        )\n\n        /**\n         * fsr\n         * run-p --\n         */\n        .command(\"run-p\", \"Run tasks in parallel\", () => {}, async function(argv) {\n            let tasks = argv._.slice();\n            tasks.shift();\n            const FcScripts = await parseScriptFile();\n            await runParallel(tasks, FcScripts);\n        })\n        .example(\n            `${taskName(\"$0 run-p start:web start:desktop\")}`,\n            `${textDescription(\"Run task 'start:web' and at the same time 'start:desktop'\")}`\n        )\n\n        /**\n         * fsr\n         * encryption --\n         */\n        .command(\"encryption\", \"Encrypt/Decrypt secret files\", () => {}, async function(argv) {\n            await encrypt.init();\n        })\n        .example(\n            `${taskName(\"$0 encryption\")}`,\n            `${textDescription(\"Encrypt/Decrypt secret files\")}`\n        )\n\n        /**\n         * fsr\n         * clear --\n         */\n        .command(\"clear\", \"Clear recent task history\", () => {}, async function(argv) {\n            await clearRecent();\n        })\n        .example(`${taskName(\"$0 clear\")}`, `${textDescription(\"Clear your recently run tasks\")}`)\n        .command(\n            \"generate\",\n            \"Generate a sample fscripts.md file from the package.json\",\n            () => {},\n            async function(argv) {\n                await generateFScripts();\n            }\n        )\n        .example(\n            `${taskName(\"$0 generate\")}`,\n            `${textDescription(\n                \"Generates a sample.fscripts.md you can use as template for your fscripts file\"\n            )}`\n        )\n        .command(\n            \"toc\",\n            \"Generate updated Table of Contents on top of the fscripts.md file\",\n            () => {},\n            async function(argv) {\n                await generateToc();\n            }\n        )\n        .example(\n            `${taskName(\"$0 toc\")}`,\n            `${textDescription(\n                \"Generate updated Table of Contents on top of the fscripts.md file\"\n            )}`\n        ).argv;\n\n    if (argv._.length === 0) {\n        (async function() {\n            const choice = await optionList();\n            if (choice) {\n                await runCLICommand(\n                    { task: { name: choice }, script: { type: \"fsr\", rest: [choice] } },\n                    true\n                );\n            } else {\n                console.log(chalk.green.bold(\"See you soon!\"));\n            }\n        })();\n    }\n})();\n"]}