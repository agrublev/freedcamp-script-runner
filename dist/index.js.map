{"version":3,"sources":["lib/helpers.js","lib/generateFScripts.js","lib/parseScriptsMd.js","lib/generateToc.js","lib/runCLICommand.js","lib/runSequence.js","lib/runParallel.js","lib/taskList.js","lib/parseScriptsPackage.js","lib/startScripts.js","lib/optionList.js","lib/git/validateNotDev.js","lib/encryption/encryption.js","index.js"],"names":["fs","require","chalk","boxen","ONE_SIXTH","ONE_THIRD","TWO_THIRDS","utils","emptyDir","f","err","console","error","desiredMode","defaultOptions","mode","ensureDir","directory","options","ensureFile","pathExists","exists","readJson","packageObj","readFile","fl","readFileSync","removeFile","remove","writeFile","contents","outputFile","writeJson","json","chainAsync","fns","curr","last","length","next","fn","appendToFile","appendFileSync","boxInform","msg","secondary","log","hex","bold","underline","padding","margin","left","top","bottom","right","borderStyle","topLeft","topRight","bottomLeft","bottomRight","horizontal","vertical","align","hue2rgb","p","q","t","hsl2rgb","h","s","l","Array","fill","rainbowGradient","len","saturation","lightness","gradient","x","push","map","c","Math","round","module","exports","inquirer","path","projectDir","process","cwd","packagePath","join","gen","scripts","mdfile","init","packageJson","Object","keys","forEach","scriptName","JoyCon","joyRead","stopDir","dirname","flattenObject","obj","prefix","reduce","acc","k","pre","assign","marked","parse","mdContent","js","lexer","listMe","filter","e","type","slice","tempItem","currentCategory","currentTask","taskOrder","item","indx","depth","text","name","tasks","description","descriptor","script","order","code","allTasks","categories","catName","ts","tasksArr","tn","parseScriptFile","filepath","data","loadSync","newContent","split","toc","generateToc","warn","red","green","exit","newFile","tocSplit","content","trim","moment","spawn","task","quiet","bgHex","format","Promise","resolve","rest","stdio","env","FORCE_COLOR","PATH","on","runCLICommand","runSequence","FcScripts","taskName","taskIndex","findIndex","params","shift","runParallel","separator","convertBold","arr","reg","boldMatches","match","m","replace","redBright","regunderline","underlineMatches","greenBright","taskList","recentTasks","choiceCategories","cat","prompt","message","choices","then","category","sepInd","indexOf","chosenInd","taskToRun","categoryName","catObj","taskNames","projectPath","packageFile","Conf","config","parsePackageFile","taskListAutoComplete","answer","startScripts","clear","get","recentTaskOptions","lastExecuted","sort","a","b","reverse","calendar","undefined","Date","now","set","startPackageScripts","packageScripts","clearRecent","optionList","choiceMessage","bgBlack","gray","simple","newBranch","checkoutLocalBranch","pub","branchname","validateNotInDev","git","__dirname","status","current","resolve1","setTimeout","CryptoJS","scriptsDir","rootDir","igPath","prettier","encrypt","encryptedFiles","pass","encryptedFile","decryptedFile","willEncrypt","sure","toEncrypt","ciphertext","AES","toString","encryptedFileLocation","decryptedFileLocation","toDecrypt","bytes","decrypt","decryptedData","enc","Utf8","dim","getPass","ignore","ignoredFiles","fscripts","filesToAdd","file","fileSplit","pop","mask","encryptDecrypt","generateFScripts","rgb","textDescription","usage","command","yargs","example","argv","_","runCommand","choice"],"mappings":"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","file":"index.js","sourceRoot":"..","sourcesContent":["const fs = require(\"fs-extra\");\nconst chalk = require(\"chalk\");\nconst boxen = require(\"boxen\");\nconst ONE_SIXTH = 1 / 6;\nconst ONE_THIRD = 1 / 3;\nconst TWO_THIRDS = 2 / 3;\nconst utils = {};\n\n/**\n * Output json file\n * @param f - file name with directory\n * @return {boolean}\n * @example\n const file = \"/tmp/this/path/does/not/exist/file.json\";\n removeFile(file);\n */\nutils.emptyDir = async f => {\n    try {\n        await fs.emptyDir(f);\n        // console.log(`${chalk.green.underline(\"Directory\")} ${chalk.bold(f)} emptied!`);\n    } catch (err) {\n        console.error(err);\n    }\n};\n\nconst desiredMode = 0o2775;\nconst defaultOptions = {\n    mode: desiredMode\n};\nutils.ensureDir = async (directory, options = defaultOptions) => {\n    try {\n        await fs.ensureDir(directory, options);\n    } catch (err) {\n        console.error(err);\n    }\n};\n\nutils.ensureFile = async f => {\n    try {\n        await fs.ensureFile(f);\n    } catch (err) {\n        console.error(err);\n    }\n};\n\n/**\n * Ensure path exists with dirs\n * @param f the file path\n * @return {boolean}\n * @example\n const file = \".fsr/config.json\";\n pathExists(file);\n */\nutils.pathExists = async f => {\n    const exists = await fs.pathExists(f);\n\n    return exists;\n};\n\n/**\n * Read json file\n * @param f - file name with directory\n * @return {Promise<void>}\n * @example\n const file = \"/tmp/this/path/does/not/exist/file.json\";\n outputJson(file);\n */\nutils.readJson = async f => {\n    try {\n        const packageObj = await fs.readJson(f);\n        // console.log(`${chalk.green.underline(\"File\")} ${chalk.bold(f)} read!`);\n        return packageObj;\n    } catch (err) {\n        console.error(err);\n        return {};\n    }\n};\n\nutils.readFile = async f => {\n    try {\n        let fl = await fs.readFileSync(f, \"utf8\");\n        return fl;\n    } catch (err) {\n        console.error(err);\n        return {};\n    }\n};\n\nutils.removeFile = async f => {\n    try {\n        // console.log(`${chalk.green.underline(\"File\")} ${chalk.bold(f)} removed!`);\n        return await fs.remove(f);\n    } catch (err) {\n        console.error(`File ${f} NOT REMOVED! ${err}`);\n        return false;\n    }\n};\n\n/**\n * Write file\n * @param f - file name with directory\n * @param contents - text inside the file\n * @return {Promise<void>}\n * @example\n const file = \"/tmp/this/path/does/not/exist/file.json\";\n writeFile(file);\n */\nutils.writeFile = async (f, contents = \"\") => {\n    try {\n        return await fs.outputFile(f, contents);\n        // console.log(`${chalk.green.underline(\"File\")} ${chalk.bold(f)} written!`);\n    } catch (err) {\n        console.error(err);\n    }\n};\n\nutils.writeJson = async (f, json = {}) => {\n    try {\n        await fs.writeJson(f, json);\n        // console.log(`${chalk.green.underline(\"File\")} ${chalk.bold(f)} written!`);\n    } catch (err) {\n        console.error(err);\n    }\n};\n\nutils.chainAsync = fns => {\n    let curr = 0;\n    const last = fns[fns.length - 1];\n    const next = () => {\n        const fn = fns[curr++];\n        fn === last ? fn() : fn(next);\n    };\n    next();\n};\n\nutils.appendToFile = async (f, contents = \"\") => {\n    try {\n        await fs.appendFileSync(f, contents);\n    } catch (err) {\n        console.error(err);\n    }\n};\n\nutils.boxInform = async (msg, secondary = \"\") => {\n    console.log(\n        boxen(\n            chalk.hex(\"#717877\")(msg) +\n                chalk.bold.underline.hex(\"#438b34\")(secondary) +\n                chalk.hex(\"#717877\")(\" \"),\n            {\n                padding: 0,\n                margin: { left: 2, top: 0, bottom: 0, right: 0 },\n                borderStyle: {\n                    topLeft: chalk.hex(\"#5a596d\")(\"╔\"),\n                    topRight: chalk.hex(\"#5a596d\")(\"╗\"),\n                    bottomLeft: chalk.hex(\"#5a596d\")(\"╚\"),\n                    bottomRight: chalk.hex(\"#5a596d\")(\"╝\"),\n                    horizontal: chalk.hex(\"#5a596d\")(\"═\"),\n                    vertical: chalk.hex(\"#5a596d\")(\"║\")\n                }, //\"round\",\n                align: \"center\" //,\n            }\n        )\n    );\n};\n\nconst hue2rgb = (p, q, t) => {\n    if (t < 0) {\n        t += 1;\n    }\n    if (t > 1) {\n        t -= 1;\n    }\n    if (t < ONE_SIXTH) {\n        return p + (q - p) * 6 * t;\n    }\n    if (t < 0.5) {\n        return q;\n    }\n    if (t < TWO_THIRDS) {\n        return p + (q - p) * (TWO_THIRDS - t) * 6;\n    }\n    return p;\n};\n\nconst hsl2rgb = (h, s, l) => {\n    if (s === 0) {\n        return new Array(3).fill(l);\n    }\n    const q = l < 0.5 ? l * s + l : l + s - l * s;\n    const p = 2 * l - q;\n    return [hue2rgb(p, q, h + ONE_THIRD), hue2rgb(p, q, h), hue2rgb(p, q, h - ONE_THIRD)];\n};\n\nutils.rainbowGradient = (len, saturation = 1, lightness = 0.5) => {\n    const gradient = [];\n    for (let x = 0; x < len; x++) {\n        gradient.push(hsl2rgb(x / len, saturation, lightness).map(c => Math.round(c * 255)));\n    }\n    return gradient;\n};\n\n// utils.emptyDir = async () => {};\nmodule.exports = utils;\n","const chalk = require(\"chalk\");\nconst inquirer = require(\"inquirer\");\n\nconst { appendToFile, writeFile, boxInform, readJson, readFile } = require(\"./helpers.js\");\nconst path = require(\"path\");\nconst projectDir = process.cwd();\nconst packagePath = path.join(projectDir, \"package.json\");\n\nconst gen = { scripts: [] };\nlet mdfile = `# First category of scripts\n\nWelcome to your new amazing fscripts.md file. It replaces the headaches of npm scripts! But so much more.\n`;\n\ngen.init = async () => {\n    try {\n        gen.packageJson = await readJson(packagePath);\n        Object.keys(gen.packageJson.scripts).forEach(scriptName => {\n            mdfile += `\\n## ${scriptName}\\n\\n${\n                gen.packageJson.scripts[scriptName]\n            }\\n\\n\\`\\`\\`bash\\n${gen.packageJson.scripts[scriptName]}\\n\\`\\`\\`\\n\\n`;\n        });\n        await writeFile(\"./sample.fscripts.md\", mdfile);\n    } catch (err) {\n        console.error(err);\n    }\n};\n\nmodule.exports = gen.init;\n","\"use strict\";\nconst JoyCon = require(\"joycon\");\nconst path = require(\"path\");\nconst chalk = require(\"chalk\");\n\nconst joyRead = new JoyCon({\n    // Stop reading at parent dir\n    // i.e. Only read file from process.cwd()\n    stopDir: path.dirname(process.cwd())\n});\nconst flattenObject = (obj, prefix = \"\") =>\n    Object.keys(obj).reduce((acc, k) => {\n        const pre = prefix.length ? prefix + \".\" : \"\";\n        if (typeof obj[k] === \"object\") Object.assign(acc, flattenObject(obj[k], pre + k));\n        else acc[pre + k] = obj[k];\n        return acc;\n    }, {});\n\nconst marked = require(\"marked\");\n\nlet parse = function(mdContent) {\n    let js = marked.lexer(mdContent);\n    js = js.filter(e => e.type !== \"space\");\n\n    // let firstHeading = js.findIndex(e => e.type === \"heading\" && e.depth === 1); //?\n    let listMe = js.slice();\n    let tempItem = {};\n    let currentCategory = \"\";\n    let currentTask = \"\";\n    let taskOrder = 0;\n    listMe.forEach((item, indx) => {\n        if (item.type === \"heading\" && item.depth === 1) {\n            taskOrder = 0;\n            currentCategory = item.text;\n            tempItem[currentCategory] = { name: item.text, tasks: {}, description: \"\" };\n            let descriptor = js[indx + 1];\n            if (descriptor.type === \"paragraph\") {\n                tempItem[currentCategory].description = descriptor.text;\n            }\n        } else if (item.type === \"heading\" && item.depth === 2) {\n            currentTask = item.text;\n            tempItem[currentCategory].tasks[currentTask] = {\n                script: \"\",\n                name: currentTask,\n                description: \"\",\n                order: taskOrder\n            };\n            taskOrder++;\n            let descriptor = js[indx + 1];\n            let code = js[indx + 2];\n            if (descriptor.type === \"paragraph\" && code.type === \"code\") {\n                tempItem[currentCategory].tasks[currentTask].description = descriptor.text;\n                tempItem[currentCategory].tasks[currentTask].script = code.text;\n            } else if (descriptor.type === \"code\") {\n                tempItem[currentCategory].tasks[currentTask].script = descriptor.text;\n            }\n        }\n    });\n    let allTasks = [];\n    let categories = Object.keys(tempItem).map(catName => {\n        let ts = tempItem[catName].tasks;\n        let tasksArr = Object.keys(ts).map(tn => ts[tn]);\n        allTasks = [...allTasks, ...tasksArr];\n        return { name: catName, ...tempItem[catName] };\n    });\n    return { categories, allTasks };\n};\nconst parseScriptFile = async () => {\n    const { path: filepath, data } = joyRead.loadSync([\"fscripts.md\"]);\n    if (!filepath) {\n        //         console.warn(\n        //             `${chalk.bold.red(\"You're missing the fscripts.md file!\")}\n        // ${chalk.green(\"Please run 'fsr generate' to get started!\")}`\n        //         );\n        //\n        //         process.exit(0);\n        //         return null;\n        return false;\n    } else {\n        // console.warn(`${chalk.bold.green(\"Located fscripts.md file!\")}`);\n        let newContent = data.split(\"<!-- end toc -->\");\n        newContent = newContent[newContent.length === 2 ? 1 : 0];\n        return parse(newContent);\n    }\n};\n\nmodule.exports = parseScriptFile;\n","const path = require(\"path\");\nconst chalk = require(\"chalk\");\nrequire(\"markdown-toc\");\nconst JoyCon = require(\"joycon\");\nconst toc = require(\"markdown-toc\");\n\nconst joyRead = new JoyCon({\n    // Stop reading at parent dir\n    // i.e. Only read file from process.cwd()\n    stopDir: path.dirname(process.cwd())\n});\nconst { writeFile } = require(\"./helpers.js\");\n// const projectDir = process.cwd();\n\nconst generateToc = async () => {\n    const { path: filepath, data } = joyRead.loadSync([\"fscripts.md\"]);\n    if (!filepath) {\n        console.warn(\n            `${chalk.bold.red(\"You're missing the fscripts.md file!\")}\n${chalk.green(\"Please run 'fsr generate' to get started!\")}`\n        );\n        process.exit(0);\n        return null;\n    } else {\n        console.warn(`${chalk.bold.green(\"Located fscripts.md file!\")}`);\n        let newFile = ``;\n        let tocSplit = data.split(\"<!-- end toc -->\");\n        if (tocSplit.length === 2) {\n            newFile = toc(tocSplit[1]).content + \"\\n<!-- end toc -->\\n\\n\" + tocSplit[1].trim();\n        } else {\n            newFile = toc(data).content + \"\\n<!-- end toc -->\\n\\n\" + data.trim();\n        }\n        await writeFile(\"./fscripts.md\", newFile);\n    }\n};\n\nmodule.exports = generateToc;\n","const chalk = require(\"chalk\");\nconst path = require(\"path\");\nconst moment = require(\"moment\");\nconst spawn = require(\"cross-spawn\");\n\nmodule.exports = async ({ script, task, type = script.type }, quiet = false) => {\n    if (!quiet) {\n        console.log(\n            `${chalk.green\n                .bgHex(\"#181c24\")\n                .bold(\"[\" + moment().format(\"HH:MM:SS\") + \"]\")}${chalk\n                .bgHex(\"#181c24\")\n                .bold.hex(\"#8c91a7\")(\" \" + task.name + \": \")}`\n        );\n    }\n    return new Promise(resolve => {\n        const cmd = spawn(type, [...script.rest], {\n            stdio: \"inherit\",\n            env: Object.assign({}, process.env, {\n                FORCE_COLOR: true,\n                PATH: `${path.resolve(\"node_modules/.bin\")}:${process.env.PATH}`\n            })\n        });\n\n        cmd.on(\"close\", code => {\n            if (code === 0) {\n                resolve();\n            } else {\n                console.error(`${chalk.red(\"ERROR\")} ${code}`);\n            }\n        });\n    });\n};\n","const runCLICommand = require(\"./runCLICommand\");\nconst chalk = require(\"chalk\");\n\nconst runSequence = async (tasks, FcScripts) => {\n    for (let t in tasks) {\n        let taskName = tasks[t];\n        let taskIndex = FcScripts.allTasks.findIndex(t => t.name === taskName);\n        if (taskIndex === -1) {\n            console.log(\n                `${chalk.red.underline(\n                    \"Skipping task \" + taskName + \", as it cannot be found in .md file\"\n                )}`\n            );\n        } else {\n            let script = FcScripts.allTasks[taskIndex].script;\n            let params = script.split(\" \");\n            let type = params.shift();\n            await runCLICommand({\n                task: { name: taskName },\n                script: {\n                    type: type,\n                    rest: params\n                }\n            });\n        }\n    }\n};\n\nmodule.exports = runSequence;\n// (async () => {\n//     await startScripts();\n// })();\n","const runCLICommand = require(\"./runCLICommand\");\n\nconst runParallel = async (tasks, FcScripts) => {\n    for (let t in tasks) {\n        let taskName = tasks[t];\n        let taskIndex = FcScripts.allTasks.findIndex(t => t.name === taskName);\n        let script = FcScripts.allTasks[taskIndex].script;\n        let params = script.split(\" \");\n        let type = params.shift();\n\n        runCLICommand({\n            task: { name: taskName },\n            script: {\n                type: type,\n                rest: params\n            }\n        });\n    }\n};\n\nmodule.exports = runParallel;\n","const inquirer = require(\"inquirer\");\nconst separator = \"   ~   \";\nconst chalk = require(\"chalk\");\nconst convertBold = arr => {\n    return arr.map(e => {\n        let reg = /(\\*\\*|^\\*\\*)(?=\\S)([\\s\\S]*?\\S)\\*\\*(?![\\*\\*\\S])/g;\n        let boldMatches = e.match(reg);\n        if (boldMatches !== null) {\n            boldMatches.forEach(m => {\n                e = e.replace(m, chalk.bold.redBright(m.replace(/\\*\\*/g, \" \"))); //.underline.bgBlack.whiteBright\n            });\n        }\n        let regunderline = /(_|^_)(?=\\S)([\\s\\S]*?\\S)_(?![_\\S])/g;\n        let underlineMatches = e.match(regunderline);\n        if (underlineMatches !== null) {\n            underlineMatches.forEach(m => {\n                e = e.replace(m, chalk.underline.greenBright(m.replace(/\\_\\_/g, \" \"))); //.underline.bgBlack.whiteBright\n            });\n        }\n        return e;\n    });\n};\nconst taskList = async (FcScripts, recentTasks) => {\n    return new Promise(resolve => {\n        let choiceCategories = [\n            ...recentTasks,\n            ...[\"-------------\"],\n            ...FcScripts.categories.map(cat => {\n                return cat.name + separator + cat.description;\n            })\n        ];\n        choiceCategories = convertBold(choiceCategories);\n        inquirer\n        .prompt([\n            {\n                type: \"list\",\n                name: \"category\",\n                message: \"What category do you want to run?\",\n                choices: choiceCategories\n            }\n        ])\n        .then(({ category }) => {\n            let sepInd = choiceCategories.indexOf(\"-------------\");\n            let chosenInd = choiceCategories.indexOf(category);\n            if (sepInd === chosenInd) {\n                console.log(\"Can't select divider\");\n            } else if (chosenInd < sepInd) {\n                let taskToRun = category.split(separator)[0].trim();\n                resolve(taskToRun);\n            } else {\n                let categoryName = category.split(separator)[0];\n                let catObj = FcScripts.categories.findIndex(e => e.name === categoryName);\n                catObj = FcScripts.categories[catObj];\n                let taskNames = Object.keys(catObj.tasks).map(taskName => {\n                    let task = catObj.tasks[taskName];\n                    return `${taskName} ${\n                        task.description\n                            ? separator + task.description.replace(/\\n/g, \" \").trim()\n                            : \"\"\n                    }`;\n                });\n                taskNames = convertBold(taskNames);\n                inquirer\n                .prompt([\n                    {\n                        type: \"list\",\n                        name: \"taskToRun\",\n                        message: \"Which task do you want to run\",\n                        choices: taskNames\n                    }\n                ])\n                .then(({ taskToRun }) => {\n                    taskToRun = taskToRun.split(separator)[0].trim();\n                    resolve(taskToRun);\n                });\n            }\n        });\n    });\n};\n\nmodule.exports = taskList;\n","\"use strict\";\nconst path = require(\"path\");\nconst chalk = require(\"chalk\");\nconst projectPath = path.join(process.cwd(), \"./package.json\");\nconst { readJson } = require(\"./helpers\");\nconst parseScriptFile = async () => {\n    const packageFile = await readJson(projectPath);\n    return packageFile.scripts;\n};\n\nmodule.exports = parseScriptFile;\n","const taskList = require(\"./taskList\");\nconst separator = \"   ~   \";\nconst Conf = require(\"conf\");\nconst config = new Conf();\nconst moment = require(\"moment\");\nconst chalk = require(\"chalk\");\nconst parseScriptFile = require(\"./parseScriptsMd.js\");\nconst parsePackageFile = require(\"./parseScriptsPackage.js\");\nconst runCLICommand = require(\"./runCLICommand\");\nconst { prompt } = require(\"enquirer\");\n\nconst taskListAutoComplete = async tasks => {\n    try {\n        let { answer } = await prompt({\n            type: \"autocomplete\",\n            message: `${chalk.green.bold.underline(\"Choose task to run\")}`,\n            choices: tasks,\n            name: `answer`\n        });\n        return answer.split(separator)[0].trim();\n    } catch (e) {\n        return false;\n    }\n};\n\nconst startScripts = async (categories = true) => {\n    console.clear();\n    const FcScripts = await parseScriptFile();\n    if (FcScripts === false) {\n        return false;\n    }\n    let recentTasks = config.get(\"recentTasks\", {});\n    let recentTaskArr = Object.keys(recentTasks)\n        .map(taskName => {\n            let task = recentTasks[taskName];\n            return { name: taskName, lastExecuted: task.lastExecuted };\n        })\n        .sort((a, b) =>\n            a.lastExecuted > b.lastExecuted ? 1 : b.lastExecuted > a.lastExecuted ? -1 : 0\n        )\n        .reverse()\n        .slice(0, 3);\n    let recentTaskOptions = recentTaskArr.map(task => {\n        return task.name + separator + moment(task.lastExecuted).calendar();\n    });\n    let taskToRun;\n    if (categories) {\n        taskToRun = await taskList(FcScripts, recentTaskOptions);\n    } else {\n        let tasks = FcScripts.allTasks;\n\n        taskToRun = await taskListAutoComplete(\n            tasks.map(task => {\n                return `${task.name}${separator}${task.description}`;\n            })\n        );\n    }\n    if (recentTasks[taskToRun] === undefined) {\n        recentTasks[taskToRun] = { lastExecuted: Date.now() };\n    } else {\n        recentTasks[taskToRun].lastExecuted = Date.now();\n    }\n    config.set(\"recentTasks\", recentTasks);\n    let taskIndex = FcScripts.allTasks.findIndex(t => t.name === taskToRun);\n    let script = FcScripts.allTasks[taskIndex].script;\n    let params = script.split(\" \");\n    let type = params.shift();\n    await runCLICommand({\n        task: { name: taskToRun },\n        script: {\n            type: type,\n            rest: params\n        }\n    });\n};\n\nconst startPackageScripts = async () => {\n    console.clear();\n    const packageScripts = await parsePackageFile();\n    let tasks = Object.keys(packageScripts).map(e => {\n        return { name: e, script: packageScripts[e] };\n    });\n\n    let taskToRun = await taskListAutoComplete(\n        tasks.map(task => {\n            return `${task.name}${separator}${task.script}`;\n        })\n    );\n    if (taskToRun === false) {\n        console.log(chalk.green.bold(\"See you soon!\"));\n        return false;\n    }\n    await runCLICommand({\n        task: { name: taskToRun },\n        script: {\n            type: \"yarn\",\n            rest: [taskToRun]\n        }\n    });\n};\n\nconst clearRecent = async () => {\n    config.set(\"recentTasks\", {});\n};\nmodule.exports = {\n    startScripts,\n    taskListAutoComplete,\n    clearRecent,\n    startPackageScripts\n};\n","const separator = \"   ~   \";\nconst chalk = require(\"chalk\");\n\nconst { prompt } = require(\"enquirer\");\nconst optionList = async () => {\n    let choiceCategories = [\n        {\n            name: \"start\",\n            message: \"Choose category then task to run\"\n        },\n        {\n            name: \"list\",\n            message: \"Select any task with text autocompletion\"\n        },\n        {\n            name: \"scripts\",\n            message: \"Choose a script from package.json\"\n        },\n        {\n            name: \"encryption\",\n            message: \"Encrypt/Decrypt secret files\"\n        },\n        {\n            name: \"clear\",\n            message: \"Clear recent task history\"\n        },\n        {\n            name: \"generate\",\n            message: \"Generate a sample fscripts.md file from the package.json\"\n        },\n        {\n            name: \"toc\",\n            message: \"Generate updated Table of Contents on top of the fscripts.md file\"\n        },\n        {\n            name: \"--help\",\n            message: \"See full help documentation\"\n        }\n    ];\n    try {\n        let { answer } = await prompt({\n            type: \"select\",\n            name: `answer`,\n            choiceMessage: e => {\n                // return JSON.stringify(e)\n                // return e.message;\n                return chalk.bgBlack.bold.hex(\"#ac80fd\")(\n                    e.name + \":\" + chalk.gray(\" \" + e.message)\n                );\n            },\n            message: `${chalk.green.bold.underline(\"Whatz category do you want to run?\")}`,\n            choices: choiceCategories\n        });\n        return answer;\n    } catch (e) {\n        return false;\n    }\n};\n\nmodule.exports = optionList;\n","const inquirer = require(\"inquirer\");\nconst chalk = require(\"chalk\");\nconst boxen = require(\"boxen\");\n\nconst simple = require(\"simple-git\");\n\nconst newBranch = async name => {\n    await simple().checkoutLocalBranch(name);\n    console.log(boxen(chalk.green(`New branch ${name} created`)));\n};\n\nasync function pub() {\n    return new Promise(resolve => {\n        inquirer\n            .prompt([\n                {\n                    type: \"input\",\n                    message: chalk.bold.hex(\"#38be18\")(`Name new feature branch (or type cancel):`),\n                    name: \"branchname\"\n                }\n            ])\n            .then(async ({ branchname }) => {\n                if (branchname !== \"CatsDontLie\") await newBranch(branchname);\n                resolve();\n            });\n    });\n}\n\nconst validateNotInDev = async () => {\n    await new Promise(async resolve => {\n        const git = require(\"simple-git/promise\");\n\n        let statusSummary = await git(__dirname).status();\n        if (statusSummary.current === \"CatsDontLie\") {\n            console.clear();\n            console.log(\n                boxen(chalk.bold.underline.red(\"DO NO MAKE CHANGES IN DEV!\"), {\n                    padding: 2\n                })\n            );\n            await new Promise(resolve1 =>\n                setTimeout(() => {\n                    resolve1();\n                }, 1000)\n            );\n            await pub();\n            resolve();\n        } else {\n            resolve();\n        }\n    });\n};\nmodule.exports = validateNotInDev;\n","const CryptoJS = require(\"crypto-js\");\nconst chalk = require(\"chalk\");\nvar inquirer = require(\"inquirer\");\n\nconst {\n    appendToFile,\n    ensureFile,\n    writeFile,\n    boxInform,\n    readJson,\n    readFile\n} = require(\"../helpers.js\");\nconst path = require(\"path\");\nconst scriptsDir = process.cwd();\nconst rootDir = path.join(scriptsDir, \"./\");\nconst packagePath = path.join(rootDir, \"package.json\");\nconst igPath = path.join(rootDir, \".gitignore\");\nconst prettier = require(\"prettier\");\nconst encrypt = { encryptedFiles: [] };\n\n// prettier-ignore\nencrypt.encrypt = async (pass, encryptedFile, decryptedFile) => {\n    let willEncrypt = true;\n    let sureSure = await ensureFile(encryptedFile);\n    if (sureSure) {\n        console.log(`${chalk.bold.red(\"FILE ALREADY EXISTS ARE YOU SURE?\")}`);\n        willEncrypt = await new Promise(resolve => {\n            inquirer\n                .prompt([\n                    {\n                        type: \"confirm\",\n                        message: chalk.bold.hex(\"#38be18\")(`Sure? (y/n): `),\n                        name: \"sure\"\n                    }\n                ])\n                .then(({ sure }) => {\n                    resolve(sure);\n                });\n        });\n    }\n    if (willEncrypt) {\n        let toEncrypt = await readFile(decryptedFile);\n        const ciphertext = CryptoJS.AES.encrypt(toEncrypt, pass);\n        await writeFile(encryptedFile, ciphertext.toString());\n    }\n\n};\n// prettier-ignore\nencrypt.decrypt = async (pass, encryptedFileLocation, decryptedFileLocation) => {\n    // let encryptedFileLocation = path.join(rootDir,\".\"+encryptedFile);\n    // let decryptedFileLocation = path.join(rootDir,encryptedFile);\n    let willEncrypt = true;\n    let sureSure = await ensureFile(decryptedFileLocation);\n    if (sureSure) {\n        console.log(`${chalk.bold.red(\"FILE ALREADY EXISTS ARE YOU SURE?\")}`);\n        willEncrypt = await new Promise(resolve => {\n            inquirer\n                .prompt([\n                    {\n                        type: \"confirm\",\n                        message: chalk.bold.hex(\"#38be18\")(`Sure wanna override file ${decryptedFileLocation}? (y/n): `),\n                        name: \"sure\"\n                    }\n                ])\n                .then(({ sure }) => {\n                    resolve(sure);\n                });\n        });\n    }\n    if (willEncrypt) {\n        let toDecrypt = await readFile(encryptedFileLocation);\n        const bytes = CryptoJS.AES.decrypt(toDecrypt, pass);\n        let decryptedData;\n        try {\n            decryptedData = bytes.toString(CryptoJS.enc.Utf8);\n        } catch (e) {\n            console.error(\"-- Console Problem \", e);\n        }\n        await writeFile(decryptedFileLocation, decryptedData);\n        console.warn(`${chalk.bold.green.underline(\"DECRYPTED FILE:\")} ${chalk.bold.dim(path.join(scriptsDir, decryptedFileLocation))}`);\n    }\n\n};\n\nencrypt.init = async () => {\n    try {\n        let pass = await encrypt.getPass();\n        let toEncrypt = await encrypt.toEncrypt();\n        encrypt.packageJson = await readJson(packagePath);\n        encrypt.ignore = await readFile(igPath);\n        encrypt.ignoredFiles = encrypt.ignore.split(\"\\n\");\n        if (encrypt.packageJson.fscripts) {\n            if (encrypt.packageJson.fscripts.encryptedFiles) {\n                encrypt.encryptedFiles = encrypt.packageJson.fscripts.encryptedFiles;\n                let filesToAdd = \"\\n\";\n                for (const e of encrypt.encryptedFiles) {\n                    if (encrypt.ignoredFiles.indexOf(e) === -1) {\n                        filesToAdd += e + \"\\n\";\n                    }\n                    let file = e + \"\";\n                    let fileSplit = file.split(\"/\");\n                    let name = fileSplit.pop();\n                    let encryptedFile = fileSplit.slice();\n                    let decryptedFile = fileSplit.slice();\n                    encryptedFile.push(\".\" + name);\n                    encryptedFile = path.join(rootDir, encryptedFile.join(\"/\"));\n                    decryptedFile.push(name);\n                    decryptedFile = path.join(rootDir, decryptedFile.join(\"/\"));\n\n                    if (toEncrypt) {\n                        await encrypt.encrypt(pass, encryptedFile, decryptedFile);\n                    } else {\n                        await encrypt.decrypt(pass, encryptedFile, decryptedFile);\n                    }\n                }\n\n                if (filesToAdd.trim().length > 0) {\n                    await appendToFile(igPath, filesToAdd + \"\\n\");\n                    boxInform(\" Added files to .gitignore: \", filesToAdd);\n                }\n            }\n        }\n    } catch (err) {\n        console.error(err);\n    }\n};\n\nencrypt.getPass = async () => {\n    return await new Promise(resolve => {\n        inquirer\n            .prompt([\n                {\n                    type: \"password\",\n                    mask: chalk.underline(\" ●\"),\n                    message: chalk.bold.hex(\"#38be18\")(`Enter a SECRET key (same as pass app) : `),\n                    name: \"pass\"\n                }\n            ])\n            .then(({ pass }) => {\n                resolve(pass);\n            });\n    });\n};\nencrypt.toEncrypt = async () => {\n    return await new Promise(resolve => {\n        inquirer\n            .prompt([\n                {\n                    type: \"list\",\n                    message: chalk.bold.hex(\"#38be18\")(\"Which direction?\"),\n                    choices: [\"encrypt\", \"decrypt\"],\n                    name: \"encryptDecrypt\"\n                }\n            ])\n            .then(async ({ encryptDecrypt }) => {\n                resolve(encryptDecrypt === \"encrypt\");\n            });\n    });\n};\n\nmodule.exports = { ...encrypt };\n","#!/usr/bin/env node\n\nconst chalk = require(\"chalk\");\nconst generateFScripts = require(\"./lib/generateFScripts.js\");\nconst parseScriptFile = require(\"./lib/parseScriptsMd.js\");\n// const parseScriptPackage = require(\"./lib/parseScriptsPackage\");\nconst generateToc = require(\"./lib/generateToc\");\nconst runSequence = require(\"./lib/runSequence\");\nconst runParallel = require(\"./lib/runParallel\");\nconst runCLICommand = require(\"./lib/runCLICommand\");\nconst { startPackageScripts, startScripts, clearRecent } = require(\"./lib/startScripts.js\");\nconst taskName = chalk.rgb(39, 173, 96).bold.underline;\nconst textDescription = chalk.rgb(159, 161, 181);\nconst optionList = require(\"./lib/optionList\");\nconst validateNotInDev = require(\"./lib/git/validateNotDev.js\");\nconst encrypt = require(\"./lib/encryption/encryption\");\n\n(async () => {\n    await validateNotInDev();\n\n    const argv = require(\"yargs\")\n        .usage(\"Usage: $0 <command> [options]\")\n        .command(\"\", \"Choose a script runner command\", yargs => {}, async function() {})\n        .example(`${taskName(\"$0\")}`, `${textDescription(\"Choose a script runner command\")}`)\n        .command(\"start\", \"Choose category then task to run\", yargs => {}, async function() {\n            if ((await startScripts()) === false) {\n                await startPackageScripts();\n            }\n        })\n        .example(`${taskName(\"$0 start\")}`, `${textDescription(\"Open a task selection selector\")}`)\n        .command(\"scripts\", \"Choose a script from package.json\", yargs => {}, async function() {\n            await startPackageScripts();\n        })\n        .example(\n            `${taskName(\"$0 scripts\")}`,\n            `${textDescription(\"Choose a script from package.json\")}`\n        )\n        .command(\"list\", \"Select any task with text autocompletion\", () => {}, async function(\n            argv\n        ) {\n            await startScripts(false);\n            // const tasks = await scriptsParsed().allTasks;\n        })\n        .example(`${taskName(\"$0 list\")}`, `${textDescription(\"Show you all tasks you can run\")}`)\n        .command(\"run\", \"Run a specific task\", () => {}, async function(argv) {\n            let task = argv._[1];\n            const FcScripts = await parseScriptFile();\n            let taskIndex = FcScripts.allTasks.findIndex(t => t.name === task);\n            let taskData = FcScripts.allTasks[taskIndex];\n            let runCommand = taskData[\"script\"].split(\" \");\n            let type = runCommand.shift();\n            let params = runCommand.join(\" \");\n            let args = Object.keys(argv)\n                .filter(e => e !== \"_\" && e !== \"$0\")\n                .map(e => ` --${e}=${argv[e]}`);\n            params += \" \" + args.join(\" \");\n            await runCLICommand({\n                task: { name: task },\n                script: {\n                    type: type,\n                    rest: params.split(\" \")\n                }\n            });\n        })\n        .example(`${taskName(\"$0 run start:web\")}`, `${textDescription(\"Run task 'start:web'\")}`)\n        .command(\"run-s\", \"Run a set of tasks one after another\", () => {}, async function(argv) {\n            let tasks = argv._.slice();\n            tasks.shift();\n            const FcScripts = await parseScriptFile();\n            await runSequence(tasks, FcScripts);\n        })\n        .example(\n            `${taskName(\"$0 run-s start:web start:desktop\")}`,\n            `${textDescription(\"Run task 'start:web' and afterwards 'start:desktop'\")}`\n        )\n        .command(\"run-p\", \"Run tasks in parallel\", () => {}, async function(argv) {\n            let tasks = argv._.slice();\n            tasks.shift();\n            const FcScripts = await parseScriptFile();\n            await runParallel(tasks, FcScripts);\n        })\n        .example(\n            `${taskName(\"$0 run-p start:web start:desktop\")}`,\n            `${textDescription(\"Run task 'start:web' and at the same time 'start:desktop'\")}`\n        )\n        .command(\"encryption\", \"Encrypt/Decrypt secret files\", () => {}, async function(argv) {\n            await encrypt.init();\n        })\n        .example(\n            `${taskName(\"$0 encryption\")}`,\n            `${textDescription(\"Encrypt/Decrypt secret files\")}`\n        )\n        .command(\"clear\", \"Clear recent task history\", () => {}, async function(argv) {\n            await clearRecent();\n        })\n        .example(`${taskName(\"$0 clear\")}`, `${textDescription(\"Clear your recently run tasks\")}`)\n        .command(\n            \"generate\",\n            \"Generate a sample fscripts.md file from the package.json\",\n            () => {},\n            async function(argv) {\n                await generateFScripts();\n            }\n        )\n        .example(\n            `${taskName(\"$0 generate\")}`,\n            `${textDescription(\n                \"Generates a sample.fscripts.md you can use as template for your fscripts file\"\n            )}`\n        )\n        .command(\n            \"toc\",\n            \"Generate updated Table of Contents on top of the fscripts.md file\",\n            () => {},\n            async function(argv) {\n                await generateToc();\n            }\n        )\n        .example(\n            `${taskName(\"$0 toc\")}`,\n            `${textDescription(\n                \"Generate updated Table of Contents on top of the fscripts.md file\"\n            )}`\n        ).argv;\n\n    if (argv._.length === 0) {\n        (async function() {\n            const choice = await optionList();\n            if (choice) {\n                await runCLICommand(\n                    { task: { name: choice }, script: { type: \"fsr\", rest: [choice] } },\n                    true\n                );\n            } else {\n                console.log(chalk.green.bold(\"See you soon!\"));\n            }\n        })();\n    }\n})();\n"]}