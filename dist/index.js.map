{"version":3,"sources":["lib/release/sort.js","lib/release/bump.js","lib/helpers.js","lib/generateFScripts.js","lib/parseScriptsMd.js","lib/generateToc.js","lib/upgradePackages.js","lib/runCLICommand.js","lib/runSequence.js","lib/runParallel.js","lib/taskList.js","lib/parseScriptsPackage.js","lib/startScripts.js","lib/optionList.js","lib/git/validateNotDev.js","lib/encryption/encryption.js","index.js"],"names":["sortObjectKeys","require","detectIndent","sortOrder","defaultNpmScripts","sortPackageJson","packageJson","options","determinedSortOrder","wasString","hasWindowsNewlines","endCharacters","indentLevel","indent","substr","newlineMatch","match","JSON","parse","prefixedScriptRegex","prefixableScripts","slice","sortSubKey","key","sortList","unique","Array","isArray","sort","filter","el","index","arr","indexOf","toSortKey","script","prefixOmitted","replace","includes","compareScriptKeys","a","b","aScript","bScript","scripts","Object","keys","forEach","push","result","stringify","module","exports","main","fs","process","argv","cwd","filePath","readFileSync","sorted","writeFileSync","console","log","versiony","inquirer","prettier","path","chalk","packagePath","resolve","existsSync","logError","exit","bump","type","Promise","prompt","message","green","bold","underline","choices","name","then","retType","vv","from","patch","minor","major","to","end","myFileContent","soPretty","format","printWidth","tabWidth","singleQuote","trailingComma","bracketSpacing","semi","useTabs","parser","jsxBracketSameLine","e","info","boxen","ONE_SIXTH","ONE_THIRD","TWO_THIRDS","utils","emptyDir","f","err","error","desiredMode","defaultOptions","mode","ensureDir","directory","ensureFile","pathExists","exists","readJson","packageObj","readFile","fl","removeFile","remove","writeFile","contents","writeJson","json","chainAsync","fns","curr","last","length","next","fn","appendToFile","appendFileSync","boxInform","msg","secondary","padding","margin","left","top","bottom","right","hex","borderStyle","topLeft","topRight","bottomLeft","bottomRight","horizontal","vertical","align","hue2rgb","p","q","t","hsl2rgb","h","s","l","fill","rainbowGradient","len","saturation","lightness","gradient","x","map","c","Math","round","projectDir","join","gen","mdfile","init","scriptName","JoyCon","joyRead","stopDir","dirname","flattenObject","obj","prefix","reduce","acc","k","pre","assign","marked","mdContent","js","lexer","listMe","tempItem","currentCategory","currentTask","taskOrder","item","indx","depth","text","tasks","description","descriptor","order","code","allTasks","categories","catName","ts","tasksArr","tn","parseScriptFile","filepath","data","loadSync","newContent","split","toc","generateToc","warn","red","newFile","tocSplit","content","trim","childProcess","logInfo","blue","logSuccess","global","ignorePkgs","upgradePackages","upgraded","before","after","element","packagesList","command","pkk","execSync","stdio","env","FORCE_COLOR","PATH","packageJsonAfter","packagesListAfter","moment","spawn","task","quiet","bgHex","rest","on","runCLICommand","runSequence","FcScripts","taskName","taskIndex","findIndex","params","shift","runParallel","separator","convertBold","reg","boldMatches","m","redBright","regunderline","underlineMatches","greenBright","taskList","recentTasks","choiceCategories","value","cat","category","sepInd","chosenInd","taskToRun","categoryName","catObj","taskNames","projectPath","packageFile","Conf","config","parsePackageFile","taskListAutoComplete","answer","startScripts","clear","get","recentTaskOptions","lastExecuted","reverse","calendar","undefined","Date","now","set","startPackageScripts","packageScripts","clearRecent","optionList","choiceMessage","black","gray","cyan","git","simple","pathToCwd","newBranch","pub","branchname","validateNotInDev","__dirname","status","current","resolve1","setTimeout","CryptoJS","scriptsDir","rootDir","igPath","encrypt","encryptedFiles","pass","encryptedFile","decryptedFile","willEncrypt","sure","toEncrypt","ciphertext","AES","toString","encryptedFileLocation","decryptedFileLocation","toDecrypt","bytes","decrypt","decryptedData","enc","Utf8","dim","getPass","ignore","ignoredFiles","fscripts","filesToAdd","file","fileSplit","pop","mask","encryptDecrypt","generateFScripts","rgb","textDescription","usage","yargs","example","_","runCommand","choice"],"mappings":";;AACA,MAAMA,EAAiBC,QAAQ,oBACzBC,EAAeD,QAAQ,iBAEvBE,EAAY,CACd,OACA,UACA,cACA,WACA,cACA,OACA,WACA,QACA,SACA,aACA,UACA,gBACA,WACA,SACA,cACA,UACA,WACA,OACA,aACA,UACA,UACA,SACA,eACA,QACA,QACA,UACA,QACA,UACA,eACA,SACA,MACA,MACA,cACA,QACA,aACA,aACA,cACA,SACA,gBACA,aACA,QACA,eACA,KACA,WACA,eACA,eACA,YACA,OACA,eACA,kBACA,mBACA,sBACA,qBACA,uBACA,OACA,cACA,UACA,eACA,KACA,MACA,eACA,iBAGEC,EAAoB,CACtB,UACA,OACA,UACA,UACA,UACA,aACA,QACA,OACA,OACA,YACA,WAGJ,SAASC,EAAgBC,EAAaC,EAAU,IACtCC,MAAAA,EAAsBD,EAAQJ,WAAaA,EAC7CM,IAAAA,GAAY,EACZC,GAAqB,EACrBC,EAAgB,GAChBC,EAAc,EACd,GAAuB,iBAAhBN,EAA0B,CACjCG,GAAY,EACZG,EAAcV,EAAaI,GAAaO,OACT,OAA3BP,EAAYQ,QAAQ,KACpBH,EAAgB,MAEdI,MAAAA,EAAeT,EAAYU,MAAM,WACvCN,EAA2D,UAArCK,GAAgBA,EAAa,IACnDT,EAAcW,KAAKC,MAAMZ,GAGvBa,MAAAA,EAAsB,iBACtBC,EAAoBhB,EAAkBiB,QAUnCC,SAAAA,EAAWC,EAAKC,EAAUC,GAC3BC,GAAAA,MAAMC,QAAQrB,EAAYiB,IAK1B,OAJAjB,EAAYiB,GAAOjB,EAAYiB,GAAKK,YAChCH,IACAnB,EAAYiB,GAAoBjB,EAAYiB,GAmCvCM,OAAO,CAACC,EAAIC,EAAOC,IAAQD,GAASC,EAAIC,QAAQH,MA/B7B,iBAArBxB,EAAYiB,KACnBjB,EAAYiB,GAAOvB,EAAeM,EAAYiB,GAAMC,IAGnDU,SAAAA,EAAUC,GACTC,MAAAA,EAAgBD,EAAOE,QAAQlB,EAAqB,MACtDC,OAAAA,EAAkBkB,SAASF,GACpBA,EAEJD,EAQFI,SAAAA,EAAkBC,EAAGC,GACtBD,GAAAA,IAAMC,EAAG,OAAO,EACdC,MAAAA,EAAUR,EAAUM,GACpBG,EAAUT,EAAUO,GACtBC,OAAAA,IAAYC,EAGRH,UAAYE,KAAaD,WAAaE,KAAmB,EAEtD,EAEJD,EAAUC,GAAW,EAAI,EAyChClC,GAtF+B,iBAAxBH,EAAYsC,SACnBC,OAAOC,KAAKxC,EAAYsC,SAASG,QAAQZ,IAC/BC,MAAAA,EAAgBD,EAAOE,QAAQlB,EAAqB,MACtDb,EAAYsC,QAAQR,KAAmBhB,EAAkBkB,SAASF,IAClEhB,EAAkB4B,KAAKZ,KA8CnCd,EAAW,WAAY,MAAM,GAC7BA,EAAW,YACXA,EAAW,OAAQ,CAAC,MAAO,UAC3BA,EAAW,UAAW,CAAC,OAAQ,QAC/BA,EAAW,SAAU,CAAC,OAAQ,QAAS,QACvCA,EAAW,OACXA,EAAW,OACXA,EAAW,cAAe,CAAC,MAAO,MAAO,MAAO,MAAO,YACvDA,EAAW,aAAc,CAAC,OAAQ,QAClCA,EAAW,UAAWiB,GACtBjB,EAAW,gBAAiBiB,GAC5BjB,EAAW,cACXA,EAAW,eACXA,EAAW,UACXA,EAAW,iBACXA,EAAW,cACXA,EAAW,SACXA,EAAW,gBACXA,EAAW,QACXA,EAAW,MACXA,EAAW,YACXA,EAAW,gBACXA,EAAW,mBACXA,EAAW,oBACXA,EAAW,uBACXA,EAAW,sBACXA,EAAW,wBACXA,EAAW,eACXA,EAAW,WACXA,EAAW,gBACXA,EAAW,MACXA,EAAW,OACXA,EAAW,gBACXA,EAAW,WACXA,EAAW,iBACXhB,EAAcN,EAAeM,EAAaE,GACtCC,EAAW,CACPwC,IAAAA,EAAShC,KAAKiC,UAAU5C,EAAa,KAAMM,GAAeD,EAIvDsC,OAHHvC,IACAuC,EAASA,EAAOZ,QAAQ,MAAO,SAE5BY,EAEJ3C,OAAAA,EAMX,GAJA6C,OAAOC,QAAU/C,EACjB8C,OAAOC,QAAQ/C,gBAAkBA,EACjC8C,OAAOC,QAAQjD,UAAYA,EAEvBF,QAAQoD,OAASF,OAAQ,CACnBG,MAAAA,EAAKrD,QAAQ,OAEIsD,QAAQC,KAAK,GAC9BD,QAAQC,KAAKnC,MAAM,GACnB,IAAIkC,QAAQE,uBAEHV,QAAQW,IACbpD,MAAAA,EAAcgD,EAAGK,aAAaD,EAAU,QACxCE,EAASvD,EAAgBC,GAC3BsD,IAAWtD,IACXgD,EAAGO,cAAcH,EAAUE,EAAQ,QACnCE,QAAQC,OAAOL;;ACrN3B,MAAMM,EAAW/D,QAAQ,YACnBgE,EAAWhE,QAAQ,YACnBiE,EAAWjE,QAAQ,YACnBkE,EAAOlE,QAAQ,QACfmE,EAAQnE,QAAQ,SAChBqD,EAAKrD,QAAQ,MACbI,EAAkBJ,QAAQ,aAChC,IAAIoE,EAAcF,EAAKG,QAAQf,QAAQE,MAAO,gBAEzCH,EAAGiB,WAAWF,KACfG,SAAS,0DACTjB,QAAQkB,KAAK,IAGjB,MAAMC,EAAO,UACHC,MAAAA,QAAa,IAAIC,QAAQN,IAC3BL,EACKY,OAAO,CACJ,CACIF,KAAM,OACNG,QAASV,EAAMW,MAAMC,KAAKC,UAAU,8BACpCC,QAAS,CAAC,QAAS,QAAS,SAC5BC,KAAM,aAGbC,KAAK,OAASC,QAAAA,MACXf,EAAQe,OAIdC,EAAKtB,EAASuB,KAAKlB,GACZ,UAATM,GAAkBW,EAAGE,QACZ,UAATb,GAAkBW,EAAGG,QAAQD,MAAM,GAC1B,UAATb,GACAW,EAAGI,QACEF,MAAM,GACNC,MAAM,GAEfH,EAAGK,GAAGtB,GAAauB,MACfC,IAAAA,QAAsBvC,EAAGK,aAAaU,EAAa,QACnDyB,EAAW,GACfD,EAAgB5E,KAAKiC,UAAU7C,EAAgBY,KAAKC,MAAM2E,KACtD,IACAC,EAAW5B,EAAS6B,OAAOF,EAAe,CACtCG,WAAY,GACZC,SAAU,EACVC,aAAa,EACbC,cAAe,OACfC,gBAAgB,EAChBC,MAAM,EACNC,SAAS,EACTC,OAAQ,OACRC,oBAAoB,IAE1B,MAAOC,GACL3C,QAAQ4C,KAAK,iBAAkBD,SAE7BnD,EAAGO,cAAcQ,EAAayB,EAAU,SAGlD3C,OAAOC,QAAUsB;;AC5DjB,MAAMpB,EAAKrD,QAAQ,YACbmE,EAAQnE,QAAQ,SAChB0G,EAAQ1G,QAAQ,SAChB2G,EAAY,EAAI,EAChBC,EAAY,EAAI,EAChBC,EAAa,EAAI,EACjBC,EAAQ,CAUdA,SAAiB,MAAA,IACT,UACMzD,EAAG0D,SAASC,GAEpB,MAAOC,GACLpD,QAAQqD,MAAMD,MAIhBE,EAAc,KACdC,EAAiB,CACnBC,KAFgB,MAIpBP,EAAMQ,UAAY,OAAOC,EAAWjH,EAAU8G,KACtC,UACM/D,EAAGiE,UAAUC,EAAWjH,GAChC,MAAO2G,GACLpD,QAAQqD,MAAMD,MAItBH,EAAMU,WAAa,OAAA,IACX,UACMnE,EAAGmE,WAAWR,GACtB,MAAOC,GACLpD,QAAQqD,MAAMD,MAYtBH,EAAMW,WAAa,OAAA,IAGRC,aAFcrE,EAAGoE,WAAWT,KAavCF,EAAMa,SAAW,OAAA,IACT,IAGOC,aAFkBvE,EAAGsE,SAASX,GAGvC,MAAOC,GAEE,OADPpD,QAAQqD,MAAMD,GACP,MAIfH,EAAMe,SAAW,OAAA,IACT,IAEOC,aADQzE,EAAGK,aAAasD,EAAG,QAEpC,MAAOC,GAEE,OADPpD,QAAQqD,MAAMD,GACP,MAIfH,EAAMiB,WAAa,OAAA,IACX,IAEO,aAAM1E,EAAG2E,OAAOhB,GACzB,MAAOC,GAEE,OADPpD,QAAQqD,cAAcF,kBAAkBC,MACjC,KAafH,EAAMmB,UAAY,OAAOjB,EAAGkB,EAAW,MAC/B,IACO7E,OAAAA,EAAGO,cAAcoD,EAAGkB,EAAU,SAEvC,MAAOjB,GACLpD,QAAQqD,MAAMD,MAItBH,EAAMqB,UAAY,OAAOnB,EAAGoB,EAAO,MAC3B,UACM/E,EAAG8E,UAAUnB,EAAGoB,GAExB,MAAOnB,GACLpD,QAAQqD,MAAMD,MAItBH,EAAMuB,WAAaC,CAAAA,IACXC,IAAAA,EAAO,EACLC,MAAAA,EAAOF,EAAIA,EAAIG,OAAS,GACxBC,EAAO,KACHC,MAAAA,EAAKL,EAAIC,KACfI,IAAOH,EAAOG,IAAOA,EAAGD,IAE5BA,MAGJ5B,EAAM8B,aAAe,OAAO5B,EAAGkB,EAAW,MAClC,UACM7E,EAAGwF,eAAe7B,EAAGkB,GAC7B,MAAOjB,GACLpD,QAAQqD,MAAMD,MAItBH,EAAMgC,UAAY,OACdC,EACAC,EAAY,GACZC,EAAU,EACVC,EAAS,CAAEC,KAAM,EAAGC,IAAK,EAAGC,OAAQ,EAAGC,MAAO,MAE9CzF,QAAQC,IACJ4C,EACIvC,EAAMoF,IAAI,UAAVpF,CAAqB4E,GACjB,KACA5E,EAAMY,KAAKC,UAAUuE,IAAI,UAAzBpF,CAAoC6E,GACpC7E,EAAMoF,IAAI,UAAVpF,CAAqB,KACzB,CACI8E,QAAAA,EACAC,OAAAA,EACAM,YAAa,CACTC,QAAStF,EAAMoF,IAAI,UAAVpF,CAAqB,KAC9BuF,SAAUvF,EAAMoF,IAAI,UAAVpF,CAAqB,KAC/BwF,WAAYxF,EAAMoF,IAAI,UAAVpF,CAAqB,KACjCyF,YAAazF,EAAMoF,IAAI,UAAVpF,CAAqB,KAClC0F,WAAY1F,EAAMoF,IAAI,UAAVpF,CAAqB,KACjC2F,SAAU3F,EAAMoF,IAAI,UAAVpF,CAAqB,MAEnC4F,MAAO,cAMvB,MAAMC,EAAU,CAACC,EAAGC,EAAGC,KACfA,EAAI,IACJA,GAAK,GAELA,EAAI,IACJA,GAAK,GAELA,EAhLU,EAAI,EAiLPF,EAAc,GAATC,EAAID,GAASE,EAEzBA,EAAI,GACGD,EAEPC,EApLW,EAAI,EAqLRF,GAAKC,EAAID,IArLL,EAAI,EAqLoBE,GAAK,EAErCF,GAGLG,EAAU,CAACC,EAAGC,EAAGC,KACfD,GAAM,IAANA,EACO,OAAA,IAAI7I,MAAM,GAAG+I,KAAKD,GAEvBL,MAAAA,EAAIK,EAAI,GAAMA,EAAID,EAAIC,EAAIA,EAAID,EAAIC,EAAID,EACtCL,EAAI,EAAIM,EAAIL,EACX,MAAA,CAACF,EAAQC,EAAGC,EAAGG,EAjMR,EAAI,GAiMoBL,EAAQC,EAAGC,EAAGG,GAAIL,EAAQC,EAAGC,EAAGG,EAjMxD,EAAI,KAoMtBvD,EAAM2D,gBAAkB,EAACC,EAAKC,EAAa,EAAGC,EAAY,MAChDC,MAAAA,EAAW,GACZ,IAAA,IAAIC,EAAI,EAAGA,EAAIJ,EAAKI,IACrBD,EAAS9H,KAAKqH,EAAQU,EAAIJ,EAAKC,EAAYC,GAAWG,IAAIC,GAAKC,KAAKC,MAAU,IAAJF,KAEvEH,OAAAA,IAIX3H,OAAOC,QAAU2D;;ACjNjB,MAAM3C,EAAQnE,QAAQ,SAChBgE,EAAWhE,QAAQ,aAEnB,aAAE4I,EAAF,UAAgBX,EAAhB,UAA2Ba,EAA3B,SAAsCnB,EAAtC,SAAgDE,GAAa7H,QAAQ,gBACrEkE,EAAOlE,QAAQ,QACfmL,EAAa7H,QAAQE,MACrBY,EAAcF,EAAKkH,KAAKD,EAAY,gBAEpCE,EAAM,CAAE1I,QAAS,IACvB,IAAI2I,EAAU,6IAKdD,EAAIE,KAAO,WACH,IACAF,EAAIhL,kBAAoBsH,EAASvD,GACjCxB,OAAOC,KAAKwI,EAAIhL,YAAYsC,SAASG,QAAQ0I,IACzCF,WAAkBE,QACdH,EAAIhL,YAAYsC,QAAQ6I,qBACTH,EAAIhL,YAAYsC,QAAQ6I,yBAEzCvD,EAAU,uBAAwBqD,GAC1C,MAAOrE,GACLpD,QAAQqD,MAAMD,MAItB/D,OAAOC,QAAUkI,EAAIE;;AC5BrB,aAsFA,SAAA,EAAA,GAAA,IAAA,IAAA,EAAA,EAAA,EAAA,UAAA,OAAA,IAAA,CAAA,IAAA,EAAA,MAAA,UAAA,GAAA,UAAA,GAAA,GAAA,EAAA,OAAA,KAAA,GAAA,mBAAA,OAAA,wBAAA,EAAA,EAAA,OAAA,OAAA,sBAAA,GAAA,OAAA,SAAA,GAAA,OAAA,OAAA,yBAAA,EAAA,GAAA,eAAA,EAAA,QAAA,SAAA,GAAA,EAAA,EAAA,EAAA,EAAA,MAAA,OAAA,EAAA,SAAA,EAAA,EAAA,EAAA,GAAA,OAAA,KAAA,EAAA,OAAA,eAAA,EAAA,EAAA,CAAA,MAAA,EAAA,YAAA,EAAA,cAAA,EAAA,UAAA,IAAA,EAAA,GAAA,EAAA,EArFA,MAAME,EAASzL,QAAQ,UACjBkE,EAAOlE,QAAQ,QACfmE,EAAQnE,QAAQ,SAEhB0L,EAAU,IAAID,EAAO,CAGvBE,QAASzH,EAAK0H,QAAQtI,QAAQE,SAE5BqI,EAAgB,CAACC,EAAKC,EAAS,KACjCnJ,OAAOC,KAAKiJ,GAAKE,OAAO,CAACC,EAAKC,KACpBC,MAAAA,EAAMJ,EAAOtD,OAASsD,EAAS,IAAM,GAGpCE,MAFe,iBAAXH,EAAII,GAAiBtJ,OAAOwJ,OAAOH,EAAKJ,EAAcC,EAAII,GAAIC,EAAMD,IAC1ED,EAAIE,EAAMD,GAAKJ,EAAII,GACjBD,GACR,IAEDI,EAASrM,QAAQ,UAEvB,IAAIiB,EAAQ,SAASqL,GACbC,IAAAA,EAAKF,EAAOG,MAAMF,GAIlBG,GAHJF,EAAKA,EAAG3K,OAAO4E,GAAgB,UAAXA,EAAE9B,OAGNtD,QACZsL,EAAW,GACXC,EAAkB,GAClBC,EAAc,GACdC,EAAY,EAChBJ,EAAO3J,QAAQ,CAACgK,EAAMC,KACdD,GAAc,YAAdA,EAAKpI,MAAqC,IAAfoI,EAAKE,MAAa,CAC7CH,EAAY,EACZF,EAAkBG,EAAKG,KACvBP,EAASC,GAAmB,CAAEzH,KAAM4H,EAAKG,KAAMC,MAAO,GAAIC,YAAa,IACnEC,IAAAA,EAAab,EAAGQ,EAAO,GACH,cAApBK,EAAW1I,OACXgI,EAASC,GAAiBQ,YAAcC,EAAWH,WAEpD,GAAkB,YAAdH,EAAKpI,MAAqC,IAAfoI,EAAKE,MAAa,CACpDJ,EAAcE,EAAKG,KACnBP,EAASC,GAAiBO,MAAMN,GAAe,CAC3C1K,OAAQ,GACRgD,KAAM0H,EACNO,YAAa,GACbE,MAAOR,GAEXA,IACIO,IAAAA,EAAab,EAAGQ,EAAO,GACvBO,EAAOf,EAAGQ,EAAO,GACG,cAApBK,EAAW1I,MAAsC,SAAd4I,EAAK5I,MACxCgI,EAASC,GAAiBO,MAAMN,GAAaO,YAAcC,EAAWH,KACtEP,EAASC,GAAiBO,MAAMN,GAAa1K,OAASoL,EAAKL,MAChC,SAApBG,EAAW1I,OAClBgI,EAASC,GAAiBO,MAAMN,GAAa1K,OAASkL,EAAWH,SAIzEM,IAAAA,EAAW,GAOR,MAAA,CAAEC,WANQ5K,OAAOC,KAAK6J,GAAU3B,IAAI0C,IACnCC,IAAAA,EAAKhB,EAASe,GAASP,MACvBS,EAAW/K,OAAOC,KAAK6K,GAAI3C,IAAI6C,GAAMF,EAAGE,IAE5C,OADAL,EAAW,IAAIA,KAAaI,GAC5B,EAAA,CAASzI,KAAMuI,GAAYf,EAASe,MAEnBF,SAAAA,IAEzB,MAAMM,EAAkB,UACd,MAAE3J,KAAM4J,EAAR,KAAkBC,GAASrC,EAAQsC,SAAS,CAAC,gBAC/C,GAACF,EASE,CAECG,IAAAA,EAAaF,EAAKG,MAAM,0BAErBjN,OADPgN,EAAaA,EAAiC,IAAtBA,EAAWxF,OAAe,EAAI,GAC/CxH,EAAMgN,GALN,OAAA,GASf/K,OAAOC,QAAU0K;;ACtFjB,MAAM3J,EAAOlE,QAAQ,QACfmE,EAAQnE,QAAQ,SACtBA,QAAQ,gBACR,MAAMyL,EAASzL,QAAQ,UACjBmO,EAAMnO,QAAQ,gBAEd0L,EAAU,IAAID,EAAO,CAGvBE,QAASzH,EAAK0H,QAAQtI,QAAQE,UAE5B,UAAEyE,GAAcjI,QAAQ,gBAGxBoO,EAAc,UACV,MAAElK,KAAM4J,EAAR,KAAkBC,GAASrC,EAAQsC,SAAS,CAAC,gBAC/C,IAACF,EAMM,OALPjK,QAAQwK,QACDlK,EAAMY,KAAKuJ,IAAI,4CAC5BnK,EAAMW,MAAM,gDAENxB,QAAQkB,KAAK,GACN,KACJ,CACHX,QAAQwK,QAAQlK,EAAMY,KAAKD,MAAM,gCAC7ByJ,IAAAA,EAAW,GACXC,EAAWT,EAAKG,MAAM,0BAEtBK,EADoB,IAApBC,EAAS/F,OACC0F,EAAIK,EAAS,IAAIC,QAAU,+BAA2BD,EAAS,GAAGE,OAElEP,EAAIJ,GAAMU,QAAU,+BAA2BV,EAAKW,aAE5DzG,EAAU,gBAAiBsG,KAIzCrL,OAAOC,QAAUiL;;;ACnCjB,MAAM/K,EAAKrD,QAAQ,MACbkE,EAAOlE,QAAQ,QACf2O,EAAe3O,QAAQ,iBACvBmE,EAAQnE,QAAQ,SAChBuE,EAAWM,IACbhB,QAAQC,IAAIK,EAAMmK,IAAI,YAAczJ,KAElC+J,EAAU/J,IACZhB,QAAQC,IAAIK,EAAM0K,KAAK,YAAchK,KAEnCiK,EAAajK,IACfhB,QAAQC,IAAIK,EAAMW,MAAM,WAAaD,KAGzC,IAAIkK,EAAS,GACT3K,EAAcF,EAAKG,QAAQf,QAAQE,MAAO,gBAEzCH,EAAGiB,WAAWF,KACfG,EAAS,0DACTjB,QAAQkB,KAAK,IAGjB,MAAMnE,EAAcL,QAAQoE,GAC5B,IAAI4K,EAAa,GACjB,MAAMC,EAAkB,UAChB5O,EAAW,UACPA,EAAW,SAAa,oBACxB2O,EAAa3O,EAAW,SAAa,mBAGzC6O,IAAAA,EAAW,CAAEC,OAAQ,GAAIC,MAAO,IAC/B,IAAA,IAAIC,IAAW,CAAC,eAAgB,kBAAmB,oBAChDhP,GAAAA,EAAYgP,GAAU,CAElBC,IAOAC,cARa3M,OAAOC,KAAKxC,EAAYgP,IAEpCzN,OAAO4N,IAAQR,EAAW3M,SAASmN,IACnCzE,IAAIyE,IACDN,EAAQ,OAAWM,GAAOnP,EAAYgP,GAASG,GACxCA,EAAM,YAEhBpE,KAAK,OAEN,IAEAuD,EAAac,SAASF,EAAS,CAC3BG,MAAO,UACPC,IAAK/M,OAAOwJ,OAAO,GAAI9I,QAAQqM,IAAK,CAChCC,aAAa,EACbC,QAAS3L,EAAKG,QAAQ,mBAAmBf,QAAQqM,IAAIE,WAGvDC,MAAAA,EAAmB9O,KAAKC,MAAMoC,EAAGK,aAAaU,IAEhD2L,IAAAA,EADkBnN,OAAOC,KAAKiN,EAAiBT,IAE9CzN,OAAO4N,IAAQR,EAAW3M,SAASmN,IACnCzE,IAAIyE,IACDN,EAAQ,MAAUM,GAAOM,EAAiBT,GAASG,GAC5CN,EAAQ,OAAWM,KAASN,EAAQ,MAAUM,eACnCA,WAAaN,EAAQ,OAAWM,YACxCN,EAAQ,MAAUM,OAErB,KAEVpE,KAAK,IACV0D,EAAWiB,GACb,MAAOvJ,GACLjC,KAAYgL,OAAa/I,QAKzCtD,OAAOC,QAAU8L;;ACxEjB,MAAM9K,EAAQnE,QAAQ,SAChBkE,EAAOlE,QAAQ,QACfgQ,EAAShQ,QAAQ,UACjBiQ,EAAQjQ,QAAQ,eAEtBkD,OAAOC,QAAU,QAASjB,OAAAA,EAAQgO,KAAAA,EAAMxL,KAAAA,EAAOxC,EAAOwC,MAAQyL,GAAQ,KAC7DA,GACDtM,QAAQC,OACDK,EAAMW,MACJsL,MAAM,WACNrL,KAAK,IAAMiL,IAASlK,OAAO,YAAc,OAAO3B,EAChDiM,MAAM,WACNrL,KAAKwE,IAAI,UAFuCpF,CAE5B,IAAM+L,EAAKhL,KAAO,SAG5C,IAAIP,QAAQN,IACH4L,EAAMvL,EAAM,IAAIxC,EAAOmO,MAAO,CACtCX,MAAO,UACPC,IAAK/M,OAAOwJ,OAAO,GAAI9I,QAAQqM,IAAK,CAChCC,aAAa,EACbC,QAAS3L,EAAKG,QAAQ,wBAAwBf,QAAQqM,IAAIE,WAI9DS,GAAG,QAAShD,IACC,IAATA,EACAjJ,IAEAR,QAAQqD,SAAS/C,EAAMmK,IAAI,YAAYhB;;AC5BvD,MAAMiD,EAAgBvQ,QAAQ,mBACxBmE,EAAQnE,QAAQ,SAEhBwQ,EAAc,MAAOtD,EAAOuD,KACzB,IAAA,IAAItG,KAAK+C,EAAO,CACbwD,IAAAA,EAAWxD,EAAM/C,GACjBwG,EAAYF,EAAUlD,SAASqD,UAAUzG,GAAKA,EAAEjF,OAASwL,GACzDC,IAAe,IAAfA,EACA9M,QAAQC,OACDK,EAAMmK,IAAItJ,UACT,iBAAmB0L,EAAW,8CAGnC,CACCxO,IACA2O,EADSJ,EAAUlD,SAASoD,GAAWzO,OACvBgM,MAAM,KACtBxJ,EAAOmM,EAAOC,cACZP,EAAc,CAChBL,KAAM,CAAEhL,KAAMwL,GACdxO,OAAQ,CACJwC,KAAMA,EACN2L,KAAMQ,QAO1B3N,OAAOC,QAAUqN;;AC5BjB,MAAMD,EAAgBvQ,QAAQ,mBAExB+Q,EAAc,MAAO7D,EAAOuD,KACzB,IAAA,IAAItG,KAAK+C,EAAO,CACbwD,IAAAA,EAAWxD,EAAM/C,GACjBwG,EAAYF,EAAUlD,SAASqD,UAAUzG,GAAKA,EAAEjF,OAASwL,GAEzDG,EADSJ,EAAUlD,SAASoD,GAAWzO,OACvBgM,MAAM,KACtBxJ,EAAOmM,EAAOC,QAElBP,EAAc,CACVL,KAAM,CAAEhL,KAAMwL,GACdxO,OAAQ,CACJwC,KAAMA,EACN2L,KAAMQ,OAMtB3N,OAAOC,QAAU4N;;ACpBjB,MAAM/M,EAAWhE,QAAQ,YACnBgR,EAAY,UACZ7M,EAAQnE,QAAQ,SAChBiR,EAAclP,GACTA,EAAIgJ,IAAIvE,IACP0K,IACAC,EAAc3K,EAAEzF,MADV,mDAEU,OAAhBoQ,GACAA,EAAYrO,QAAQsO,IAChB5K,EAAIA,EAAEpE,QAAQgP,EAAGjN,EAAMY,KAAKsM,UAAUD,EAAEhP,QAAQ,QAAS,SAG7DkP,IACAC,EAAmB/K,EAAEzF,MADN,uCAOZyF,OALkB,OAArB+K,GACAA,EAAiBzO,QAAQsO,IACrB5K,EAAIA,EAAEpE,QAAQgP,EAAGjN,EAAMa,UAAUwM,YAAYJ,EAAEhP,QAAQ,QAAS,SAGjEoE,IAGTiL,EAAW,MAAOhB,EAAWiB,IACxB,IAAI/M,QAAQN,IACXsN,IAAAA,EAAmB,IAChBD,EACH,CAAExM,KAAM,gBAAiB0M,MAAO,SAC7BnB,EAAUjD,WAAWzC,IAAI8G,IACjB,CACH3M,QAASf,EAAMY,KAAKC,UAAUF,MAAM+M,EAAI3M,iBAAsB2M,EAAI1E,cAClEyE,MAAOC,EAAI3M,SAIvBlB,EACKY,OAAO,CACJ,CACIF,KAAM,OACNQ,KAAM,WACNL,QAAS,oCACTI,QAAS0M,KAGhBxM,KAAK,EAAG2M,SAAAA,MACDC,IAAAA,EAASJ,EAAiB3P,QAAQ,iBAClCgQ,EAAYL,EAAiB3P,QAAQ8P,GACrCA,GAAa,OAAbA,EACAjO,QAAQC,IAAI,6BACT,GAAIkO,EAAYD,EAAQ,CACvBE,IAAAA,EAAYH,EAAS5D,MAhD3B,WAgD4C,GAAGQ,OAC7CrK,EAAQ4N,OACL,CACCC,IAAAA,EAAeJ,EAAS5D,MAnD9B,WAmD+C,GACzCiE,EAAS1B,EAAUjD,WAAWoD,UAAUpK,GAAKA,EAAEtB,OAASgN,GAC5DC,EAAS1B,EAAUjD,WAAW2E,GAC1BC,IAAAA,EAAYxP,OAAOC,KAAKsP,EAAOjF,OAAOnC,IAAI2F,IACtCR,IAAAA,EAAOiC,EAAOjF,MAAMwD,GAChB,SAAEA,KACNR,EAAK/C,YAzDf,UA0D4B+C,EAAK/C,YAAY/K,QAAQ,MAAO,KAAKsM,OACjD,OAGd0D,EAAYnB,EAAYmB,GACxBpO,EACKY,OAAO,CACJ,CACIF,KAAM,OACNQ,KAAM,YACNL,QAAS,gCACTI,QAASmN,KAGhBjN,KAAK,EAAG8M,UAAAA,MACLA,EAAYA,EAAU/D,MAzEhC,WAyEiD,GAAGQ,OAC1CrK,EAAQ4N,UAOpC/O,OAAOC,QAAUsO;;AClFjB,aACA,MAAMvN,EAAOlE,QAAQ,QACfmE,EAAQnE,QAAQ,SAChBqS,EAAcnO,EAAKkH,KAAK9H,QAAQE,MAAO,mBACvC,SAAEmE,GAAa3H,QAAQ,aACvB6N,EAAkB,UAEbyE,aADmB3K,EAAS0K,IAChB1P,SAGvBO,OAAOC,QAAU0K;;ACVjB,MAAM4D,EAAWzR,QAAQ,cACnBgR,EAAY,UACZuB,EAAOvS,QAAQ,QACfwS,EAAS,IAAID,EACbvC,EAAShQ,QAAQ,UACjBmE,EAAQnE,QAAQ,SAChB6N,EAAkB7N,QAAQ,uBAC1ByS,EAAmBzS,QAAQ,4BAC3BuQ,EAAgBvQ,QAAQ,oBACxB,OAAE4E,GAAW5E,QAAQ,YAErB0S,EAAuB,MAAA,IACrB,IACI,IAAA,OAAEC,SAAiB/N,EAAO,CAC1BF,KAAM,eACNG,WAAYV,EAAMW,MAAMC,KAAKC,UAAU,wBACvCC,QAASiI,EACThI,KAAO,WAEJyN,OAAAA,EAAOzE,MAlBJ,WAkBqB,GAAGQ,OACpC,MAAOlI,GACE,OAAA,IAIToM,EAAe,MAAOpF,GAAa,KACrC3J,QAAQgP,QACFpC,MAAAA,QAAkB5C,IACpB4C,IAAc,IAAdA,EACO,OAAA,EAEPiB,IAcAO,EAdAP,EAAcc,EAAOM,IAAI,cAAe,IAWxCC,EAVgBnQ,OAAOC,KAAK6O,GAC3B3G,IAAI2F,IAEM,MAAA,CAAExL,KAAMwL,EAAUsC,aADdtB,EAAYhB,GACqBsC,gBAE/CrR,KAAK,CAACY,EAAGC,IACND,EAAEyQ,aAAexQ,EAAEwQ,aAAe,EAAIxQ,EAAEwQ,aAAezQ,EAAEyQ,cAAgB,EAAI,GAEhFC,UACA7R,MAAM,EAAG,GACwB2J,IAAImF,GAC/BA,EAAKhL,KA1CF,UA0CqB8K,EAAOE,EAAK8C,cAAcE,YAGzD1F,GAAAA,EACAyE,QAAkBR,EAAShB,EAAWsC,OACnC,CACC7F,IAAAA,EAAQuD,EAAUlD,SAEtB0E,QAAkBS,EACdxF,EAAMnC,IAAImF,MACIA,EAAKhL,cAAmBgL,EAAK/C,qBAIpBgG,IAA3BzB,EAAYO,GACZP,EAAYO,GAAa,CAAEe,aAAcI,KAAKC,OAE9C3B,EAAYO,GAAWe,aAAeI,KAAKC,MAE/Cb,EAAOc,IAAI,cAAe5B,GACtBf,IAAAA,EAAYF,EAAUlD,SAASqD,UAAUzG,GAAKA,EAAEjF,OAAS+M,GAEzDpB,EADSJ,EAAUlD,SAASoD,GAAWzO,OACvBgM,MAAM,KACtBxJ,EAAOmM,EAAOC,cACZP,EAAc,CAChBL,KAAM,CAAEhL,KAAM+M,GACd/P,OAAQ,CACJwC,KAAMA,EACN2L,KAAMQ,MAKZ0C,EAAsB,UACxB1P,QAAQgP,QACFW,MAAAA,QAAuBf,IACzBvF,IAAAA,EAAQtK,OAAOC,KAAK2Q,GAAgBzI,IAAIvE,IACjC,CAAEtB,KAAMsB,EAAGtE,OAAQsR,EAAehN,MAGzCyL,QAAkBS,EAClBxF,EAAMnC,IAAImF,MACIA,EAAKhL,cAAmBgL,EAAKhO,WAG3C+P,IAAc,IAAdA,EAEO,OADPpO,QAAQC,IAAIK,EAAMW,MAAMC,KAAK,mBACtB,QAELwL,EAAc,CAChBL,KAAM,CAAEhL,KAAM+M,GACd/P,OAAQ,CACJwC,KAAM,OACN2L,KAAM,CAAC4B,OAKbwB,EAAc,UAChBjB,EAAOc,IAAI,cAAe,KAE9BpQ,OAAOC,QAAU,CACbyP,aAAAA,EACAF,qBAAAA,EACAe,YAAAA,EACAF,oBAAAA;;AC5GJ,MAAMvC,EAAY,UACZ7M,EAAQnE,QAAQ,UAEhB,OAAE4E,GAAW5E,QAAQ,YACrB0T,EAAa,UACX/B,IAAAA,EAAmB,CACnB,CACIzM,KAAM,QACNL,QAAS,oCAEb,CACIK,KAAM,OACNL,QAAS,4CAEb,CACIK,KAAM,UACNL,QAAS,qCAEb,CACIK,KAAM,UACNL,QAAS,0EAEb,CACIK,KAAM,OACNL,QAAS,sCAEb,CACIK,KAAM,aACNL,QAAS,gCAEb,CACIK,KAAM,QACNL,QAAS,6BAEb,CACIK,KAAM,WACNL,QAAS,4DAEb,CACIK,KAAM,MACNL,QAAS,qEAEb,CACIK,KAAM,SACNL,QAAS,gCAGb,IACI,IAAA,OAAE8N,SAAiB/N,EAAO,CAC1BF,KAAM,SACNQ,KAAO,SACPyO,cAAenN,GAGJrC,EAAMY,KAAKC,UAAU4O,MAAMpN,EAAEtB,KAAO,IAAMf,EAAM0P,KAAK,IAAMrN,EAAE3B,UAExEA,WAAYV,EAAM2P,KAAK/O,KAAKC,UAAU,wCACtCC,QAAS0M,IAENgB,OAAAA,EACT,MAAOnM,GACE,OAAA,IAIftD,OAAOC,QAAUuQ;;ACjEjB,MAAM1P,EAAWhE,QAAQ,YACnBmE,EAAQnE,QAAQ,SAChB0G,EAAQ1G,QAAQ,UAChB,UAAE8I,GAAc9I,QAAQ,iBACxB+T,EAAM/T,QAAQ,aACdgU,EAAShU,QAAQ,cACjBiU,EAAY3Q,QAAQE,MAEpB0Q,EAAY,MAAA,IAaV,IAEDvF,aAAac,+EAC8DvK,IACtE,CACIwK,MAAO,UACPC,IAAK/M,OAAOwJ,OAAO,GAAI9I,QAAQqM,IAAK,CAChCC,aAAa,EACbC,QAAS3L,KAAKG,QAAQ,mBAAmBf,QAAQqM,IAAIE,WAInE,MAAOrJ,IAITsC,EAAU3E,EAAMW,oBAAoBI,YAAgB,GAAI,KAG5D,eAAeiP,IACJ,OAAA,IAAIxP,QAAQN,IACfL,EACKY,OAAO,CACJ,CACIF,KAAM,QACNG,QAASV,EAAMY,KAAKwE,IAAI,UAAfpF,CAA2B,6CACpCe,KAAM,gBAGbC,KAAK,OAASiP,WAAAA,MACQ,gBAAfA,SAAoCF,EAAUE,GAClD/P,QAKhB,MAAMgQ,EAAmB,gBACf,IAAI1P,QAAQ,MAAA,IACRoP,MAAAA,EAAM/T,QAAQ,sBAGU,uBADJ+T,EAAIO,WAAWC,UACvBC,SACd3Q,QAAQgP,QACRhP,QAAQC,IACJ4C,EAAMvC,EAAMY,KAAKC,UAAUsJ,IAAI,8BAA+B,CAC1DrF,QAAS,WAGX,IAAItE,QAAQ8P,GACdC,WAAW,KACPD,KACD,YAEDN,IACN9P,KAEAA,OAIZnB,OAAOC,QAAUkR;;AC+EjB,SAAA,EAAA,GAAA,IAAA,IAAA,EAAA,EAAA,EAAA,UAAA,OAAA,IAAA,CAAA,IAAA,EAAA,MAAA,UAAA,GAAA,UAAA,GAAA,GAAA,EAAA,OAAA,KAAA,GAAA,mBAAA,OAAA,wBAAA,EAAA,EAAA,OAAA,OAAA,sBAAA,GAAA,OAAA,SAAA,GAAA,OAAA,OAAA,yBAAA,EAAA,GAAA,eAAA,EAAA,QAAA,SAAA,GAAA,EAAA,EAAA,EAAA,EAAA,MAAA,OAAA,EAAA,SAAA,EAAA,EAAA,EAAA,GAAA,OAAA,KAAA,EAAA,OAAA,eAAA,EAAA,EAAA,CAAA,MAAA,EAAA,YAAA,EAAA,cAAA,EAAA,UAAA,IAAA,EAAA,GAAA,EAAA,EAhKA,MAAMM,EAAW3U,QAAQ,aACnBmE,EAAQnE,QAAQ,SACtB,IAAIgE,EAAWhE,QAAQ,YAEvB,MAAM,aACF4I,EADE,WAEFpB,EAFE,UAGFS,EAHE,UAIFa,EAJE,SAKFnB,EALE,SAMFE,GACA7H,QAAQ,iBACNkE,EAAOlE,QAAQ,QACf4U,EAAatR,QAAQE,MACrBqR,EAAU3Q,EAAKkH,KAAKwJ,EAAY,MAChCxQ,EAAcF,EAAKkH,KAAKyJ,EAAS,gBACjCC,EAAS5Q,EAAKkH,KAAKyJ,EAAS,cAC5B5Q,EAAWjE,QAAQ,YACnB+U,EAAU,CAAEC,eAAgB,GAGlCD,QAAkB,MAAOE,EAAMC,EAAeC,KACtCC,IAAAA,GAAc,EAkBdA,SAjBiB5N,EAAW0N,KAE5BrR,QAAQC,OAAOK,EAAMY,KAAKuJ,IAAI,wCAC9B8G,QAAoB,IAAIzQ,QAAQN,IAC5BL,EACKY,OAAO,CACJ,CACIF,KAAM,UACNG,QAASV,EAAMY,KAAKwE,IAAI,UAAfpF,CAA2B,iBACpCe,KAAM,UAGbC,KAAK,EAAGkQ,KAAAA,MACLhR,EAAQgR,QAIpBD,EAAa,CACTE,IAAAA,QAAkBzN,EAASsN,GACzBI,MAAAA,EAAaZ,EAASa,IAAIT,QAAQO,EAAWL,SAC7ChN,EAAUiN,EAAeK,EAAWE,cAKlDV,QAAkB,MAAOE,EAAMS,EAAuBC,KAG9CP,IAAAA,GAAc,EAkBdA,SAjBiB5N,EAAWmO,KAE5B9R,QAAQC,OAAOK,EAAMY,KAAKuJ,IAAI,wCAC9B8G,QAAoB,IAAIzQ,QAAQN,IAC5BL,EACKY,OAAO,CACJ,CACIF,KAAM,UACNG,QAASV,EAAMY,KAAKwE,IAAI,UAAfpF,6BAAsDwR,cAC/DzQ,KAAM,UAGbC,KAAK,EAAGkQ,KAAAA,MACLhR,EAAQgR,QAIpBD,EAAa,CACTQ,IAAAA,QAAkB/N,EAAS6N,GACzBG,MAAAA,EAAQlB,EAASa,IAAIM,QAAQF,EAAWX,GAC1Cc,IAAAA,EACA,IACAA,EAAgBF,EAAMJ,SAASd,EAASqB,IAAIC,MAC9C,MAAOzP,GACL3C,QAAQqD,MAAM,sBAAuBV,SAEnCyB,EAAU0N,EAAuBI,GACvClS,QAAQwK,QAAQlK,EAAMY,KAAKD,MAAME,UAAU,sBAAsBb,EAAMY,KAAKmR,IAAIhS,EAAKkH,KAAKwJ,EAAYe,SAK9GZ,KAAe,UACP,IACIE,IAAAA,QAAaF,EAAQoB,UACrBb,QAAkBP,EAAQO,YAI1BP,GAHJA,EAAQ1U,kBAAoBsH,EAASvD,GACrC2Q,EAAQqB,aAAevO,EAASiN,GAChCC,EAAQsB,aAAetB,EAAQqB,OAAOlI,MAAM,MACxC6G,EAAQ1U,YAAYiW,UAChBvB,EAAQ1U,YAAYiW,SAAStB,eAAgB,CAC7CD,EAAQC,eAAiBD,EAAQ1U,YAAYiW,SAAStB,eAClDuB,IAAAA,EAAa,KACZ,IAAA,MAAM/P,KAAKuO,EAAQC,eAAgB,EACK,IAArCD,EAAQsB,aAAarU,QAAQwE,KAC7B+P,GAAc/P,EAAI,MAElBgQ,IACAC,GADOjQ,EAAI,IACM0H,MAAM,KACvBhJ,EAAOuR,EAAUC,MACjBxB,EAAgBuB,EAAUrV,QAC1B+T,EAAgBsB,EAAUrV,QAC9B8T,EAAcnS,KAAK,IAAMmC,GACzBgQ,EAAgBhR,EAAKkH,KAAKyJ,EAASK,EAAc9J,KAAK,MACtD+J,EAAcpS,KAAKmC,GACnBiQ,EAAgBjR,EAAKkH,KAAKyJ,EAASM,EAAc/J,KAAK,MAElDkK,QACMP,EAAQA,QAAQE,EAAMC,EAAeC,SAErCJ,EAAQe,QAAQb,EAAMC,EAAeC,GAI/CoB,EAAW7H,OAAOjG,OAAS,UACrBG,EAAakM,EAAQyB,EAAa,MACxCzN,EAAU,+BAAgCyN,KAIxD,MAAOtP,GACLpD,QAAQqD,MAAMD,KAItB8N,QAAkB,eACD,IAAIpQ,QAAQN,IACrBL,EACKY,OAAO,CACJ,CACIF,KAAM,WACNiS,KAAMxS,EAAMa,UAAU,MACtBH,QAASV,EAAMY,KAAKwE,IAAI,UAAfpF,CAA2B,4CACpCe,KAAM,UAGbC,KAAK,EAAG8P,KAAAA,MACL5Q,EAAQ4Q,OAIxBF,UAAoB,eACH,IAAIpQ,QAAQN,IACrBL,EACKY,OAAO,CACJ,CACIF,KAAM,OACNG,QAASV,EAAMY,KAAKwE,IAAI,UAAfpF,CAA0B,oBACnCc,QAAS,CAAC,UAAW,WACrBC,KAAM,oBAGbC,KAAK,OAASyR,eAAAA,MACXvS,EAA2B,YAAnBuS,QAKxB1T,OAAOC,QAAe4R,EAAAA,GAAAA;;;AC/JtB,MAAMtQ,EAAOzE,QAAQ,yBACfmE,EAAQnE,QAAQ,SAChB6W,EAAmB7W,QAAQ,6BAC3B6N,EAAkB7N,QAAQ,2BAE1BoO,EAAcpO,QAAQ,qBACtBiP,EAAkBjP,QAAQ,yBAC1BwQ,EAAcxQ,QAAQ,qBACtB+Q,EAAc/Q,QAAQ,qBACtBuQ,EAAgBvQ,QAAQ,wBACxB,oBAAEuT,EAAF,aAAuBX,EAAvB,YAAqCa,GAAgBzT,QAAQ,yBAC7D0Q,EAAWvM,EAAM2S,IAAI,GAAI,IAAK,IAAI/R,KAAKC,UACvC+R,EAAkB5S,EAAM2S,IAAI,IAAK,IAAK,KACtCpD,EAAa1T,QAAQ,oBACrBqU,EAAmBrU,QAAQ,+BAC3B+U,EAAU/U,QAAQ,+BAExB,WA4L0B,IA3LTA,QAAQ,SAChBgX,MAAM,iCAKNzH,QAAQ,GAAI,iCAAkC0H,MAAa,oBAC3DC,WAAWxG,EAAS,WAAYqG,EAAgB,qCAKhDxH,QACG,SACA,2CACA0H,MACA,uBACU5C,MAGb6C,WAAWxG,EAAS,WAAYqG,EAAgB,uCAMhDxH,QAAQ,QAAS,mCAAoC0H,MAAa,kBAChC,UAApBrE,WACDW,MAGb2D,WAAWxG,EAAS,iBAAkBqG,EAAgB,qCAMtDxH,QAAQ,UAAW,oCAAqC0H,MAAa,uBAC5D1D,MAET2D,WACMxG,EAAS,mBACTqG,EAAgB,wCAOtBxH,QAAQ,OAAQ,2CAA4C,OAAU,eACnEhM,SAEMqP,GAAa,KAGtBsE,WAAWxG,EAAS,gBAAiBqG,EAAgB,qCAMrDxH,QAAQ,MAAO,sBAAuB,OAAU,eAAehM,GACxD2M,IAAAA,EAAO3M,EAAK4T,EAAE,GACZ1G,MAAAA,QAAkB5C,IACpB8C,IAAAA,EAAYF,EAAUlD,SAASqD,UAAUzG,GAAKA,EAAEjF,OAASgL,GAEzDkH,EADW3G,EAAUlD,SAASoD,GACT,OAAWzC,MAAM,KACtCxJ,EAAO0S,EAAWtG,QAClBD,EAASuG,EAAWhM,KAAK,KAI7ByF,GAAU,IAHCjO,OAAOC,KAAKU,GAClB3B,OAAO4E,GAAW,MAANA,GAAmB,OAANA,GACzBuE,IAAIvE,SAAWA,KAAKjD,EAAKiD,MACT4E,KAAK,WACpBmF,EAAc,CAChBL,KAAM,CAAEhL,KAAMgL,GACdhO,OAAQ,CACJwC,KAAMA,EACN2L,KAAMQ,EAAO3C,MAAM,UAI9BgJ,WAAWxG,EAAS,yBAA0BqG,EAAgB,2BAM9DxH,QACG,UACA,yEACA,OACA,eAAehM,GACAA,EAAK4T,EAAE,SACZlI,MAGbiI,WAAWxG,EAAS,mBAAoBqG,EAAgB,gBAMxDxH,QAAQ,OAAQ,qCAAsC,OAAU,eAAehM,GACjEA,EAAK4T,EAAE,SACZ1S,MAETyS,WAAWxG,EAAS,gBAAiBqG,EAAgB,yBAMrDxH,QAAQ,QAAS,uCAAwC,OAAU,eAAehM,GAC3E2J,IAAAA,EAAQ3J,EAAK4T,EAAE/V,QACnB8L,EAAM4D,QACAL,MAAAA,QAAkB5C,UAClB2C,EAAYtD,EAAOuD,KAE5ByG,WACMxG,EAAS,yCACTqG,EAAgB,0DAOtBxH,QAAQ,QAAS,wBAAyB,OAAU,eAAehM,GAC5D2J,IAAAA,EAAQ3J,EAAK4T,EAAE/V,QACnB8L,EAAM4D,QACAL,MAAAA,QAAkB5C,UAClBkD,EAAY7D,EAAOuD,KAE5ByG,WACMxG,EAAS,yCACTqG,EAAgB,gEAOtBxH,QAAQ,aAAc,+BAAgC,OAAU,eAAehM,SACtEwR,EAAQxJ,SAEjB2L,WACMxG,EAAS,sBACTqG,EAAgB,mCAOtBxH,QAAQ,QAAS,4BAA6B,OAAU,eAAehM,SAC9DkQ,MAETyD,WAAWxG,EAAS,iBAAkBqG,EAAgB,oCACtDxH,QACG,WACA,2DACA,OACA,eAAehM,SACLsT,MAGbK,WACMxG,EAAS,oBACTqG,EACC,oFAGPxH,QACG,MACA,oEACA,OACA,eAAehM,SACL6K,MAGb8I,WACMxG,EAAS,eACTqG,EACC,wEAENxT,KAEG4T,EAAE1O,QACN,iBACS4O,MAAAA,QAAe3D,IACjB2D,QACM9G,EACF,CAAEL,KAAM,CAAEhL,KAAMmS,GAAUnV,OAAQ,CAAEwC,KAAM,MAAO2L,KAAM,CAACgH,MACxD,GAGJxT,QAAQC,IAAIK,EAAMW,MAAMC,KAAK,kBARpC,IA7LT","file":"index.js","sourceRoot":"..","sourcesContent":["#!/usr/bin/env node\nconst sortObjectKeys = require(\"sort-object-keys\");\nconst detectIndent = require(\"detect-indent\");\n\nconst sortOrder = [\n    \"name\",\n    \"version\",\n    \"description\",\n    \"keywords\",\n    \"sideEffects\",\n    \"main\",\n    \"umd:main\",\n    \"unpkg\",\n    \"module\",\n    \"workspaces\",\n    \"scripts\",\n    \"betterScripts\",\n    \"fscripts\",\n    \"source\",\n    \"jsnext:main\",\n    \"browser\",\n    \"homepage\",\n    \"bugs\",\n    \"repository\",\n    \"private\",\n    \"license\",\n    \"author\",\n    \"contributors\",\n    \"files\",\n    \"types\",\n    \"typings\",\n    \"style\",\n    \"example\",\n    \"examplestyle\",\n    \"assets\",\n    \"bin\",\n    \"man\",\n    \"directories\",\n    \"husky\",\n    \"pre-commit\",\n    \"commitlint\",\n    \"lint-staged\",\n    \"config\",\n    \"nodemonConfig\",\n    \"browserify\",\n    \"babel\",\n    \"browserslist\",\n    \"xo\",\n    \"prettier\",\n    \"eslintConfig\",\n    \"eslintIgnore\",\n    \"stylelint\",\n    \"jest\",\n    \"dependencies\",\n    \"devDependencies\",\n    \"peerDependencies\",\n    \"bundledDependencies\",\n    \"bundleDependencies\",\n    \"optionalDependencies\",\n    \"flat\",\n    \"resolutions\",\n    \"engines\",\n    \"engineStrict\",\n    \"os\",\n    \"cpu\",\n    \"preferGlobal\",\n    \"publishConfig\"\n];\n// See https://docs.npmjs.com/misc/scripts\nconst defaultNpmScripts = [\n    \"install\",\n    \"pack\",\n    \"prepare\",\n    \"publish\",\n    \"restart\",\n    \"shrinkwrap\",\n    \"start\",\n    \"stop\",\n    \"test\",\n    \"uninstall\",\n    \"version\"\n];\n\nfunction sortPackageJson(packageJson, options = {}) {\n    const determinedSortOrder = options.sortOrder || sortOrder;\n    let wasString = false;\n    let hasWindowsNewlines = false;\n    let endCharacters = \"\";\n    let indentLevel = 2;\n    if (typeof packageJson === \"string\") {\n        wasString = true;\n        indentLevel = detectIndent(packageJson).indent;\n        if (packageJson.substr(-1) === \"\\n\") {\n            endCharacters = \"\\n\";\n        }\n        const newlineMatch = packageJson.match(/(\\r?\\n)/);\n        hasWindowsNewlines = (newlineMatch && newlineMatch[0]) === \"\\r\\n\";\n        packageJson = JSON.parse(packageJson);\n    }\n\n    const prefixedScriptRegex = /^(pre|post)(.)/;\n    const prefixableScripts = defaultNpmScripts.slice();\n    if (typeof packageJson.scripts === \"object\") {\n        Object.keys(packageJson.scripts).forEach(script => {\n            const prefixOmitted = script.replace(prefixedScriptRegex, \"$2\");\n            if (packageJson.scripts[prefixOmitted] && !prefixableScripts.includes(prefixOmitted)) {\n                prefixableScripts.push(prefixOmitted);\n            }\n        });\n    }\n\n    function sortSubKey(key, sortList, unique) {\n        if (Array.isArray(packageJson[key])) {\n            packageJson[key] = packageJson[key].sort();\n            if (unique) {\n                packageJson[key] = array_unique(packageJson[key]);\n            }\n            return;\n        }\n        if (typeof packageJson[key] === \"object\") {\n            packageJson[key] = sortObjectKeys(packageJson[key], sortList);\n        }\n    }\n    function toSortKey(script) {\n        const prefixOmitted = script.replace(prefixedScriptRegex, \"$2\");\n        if (prefixableScripts.includes(prefixOmitted)) {\n            return prefixOmitted;\n        }\n        return script;\n    }\n    /*             b\n     *       pre | * | post\n     *   pre  0  | - |  -\n     * a  *   +  | 0 |  -\n     *   post +  | + |  0\n     */\n    function compareScriptKeys(a, b) {\n        if (a === b) return 0;\n        const aScript = toSortKey(a);\n        const bScript = toSortKey(b);\n        if (aScript === bScript) {\n            // pre* is always smaller; post* is always bigger\n            // Covers: pre* vs. *; pre* vs. post*; * vs. post*\n            if (a === `pre${aScript}` || b === `post${bScript}`) return -1;\n            // The rest is bigger: * vs. *pre; *post vs. *pre; *post vs. *\n            return 1;\n        }\n        return aScript < bScript ? -1 : 1;\n    }\n    function array_unique(array) {\n        return array.filter((el, index, arr) => index == arr.indexOf(el));\n    }\n    sortSubKey(\"keywords\", null, true);\n    sortSubKey(\"homepage\");\n    sortSubKey(\"bugs\", [\"url\", \"email\"]);\n    sortSubKey(\"license\", [\"type\", \"url\"]);\n    sortSubKey(\"author\", [\"name\", \"email\", \"url\"]);\n    sortSubKey(\"bin\");\n    sortSubKey(\"man\");\n    sortSubKey(\"directories\", [\"lib\", \"bin\", \"man\", \"doc\", \"example\"]);\n    sortSubKey(\"repository\", [\"type\", \"url\"]);\n    sortSubKey(\"scripts\", compareScriptKeys);\n    sortSubKey(\"betterScripts\", compareScriptKeys);\n    sortSubKey(\"commitlint\");\n    sortSubKey(\"lint-staged\");\n    sortSubKey(\"config\");\n    sortSubKey(\"nodemonConfig\");\n    sortSubKey(\"browserify\");\n    sortSubKey(\"babel\");\n    sortSubKey(\"eslintConfig\");\n    sortSubKey(\"jest\");\n    sortSubKey(\"xo\");\n    sortSubKey(\"prettier\");\n    sortSubKey(\"dependencies\");\n    sortSubKey(\"devDependencies\");\n    sortSubKey(\"peerDependencies\");\n    sortSubKey(\"bundledDependencies\");\n    sortSubKey(\"bundleDependencies\");\n    sortSubKey(\"optionalDependencies\");\n    sortSubKey(\"resolutions\");\n    sortSubKey(\"engines\");\n    sortSubKey(\"engineStrict\");\n    sortSubKey(\"os\");\n    sortSubKey(\"cpu\");\n    sortSubKey(\"preferGlobal\");\n    sortSubKey(\"private\");\n    sortSubKey(\"publishConfig\");\n    packageJson = sortObjectKeys(packageJson, determinedSortOrder);\n    if (wasString) {\n        let result = JSON.stringify(packageJson, null, indentLevel) + endCharacters;\n        if (hasWindowsNewlines) {\n            result = result.replace(/\\n/g, \"\\r\\n\");\n        }\n        return result;\n    }\n    return packageJson;\n}\nmodule.exports = sortPackageJson;\nmodule.exports.sortPackageJson = sortPackageJson;\nmodule.exports.sortOrder = sortOrder;\n\nif (require.main === module) {\n    const fs = require(\"fs\");\n\n    const filesToProcess = process.argv[2]\n        ? process.argv.slice(2)\n        : [`${process.cwd()}/package.json`];\n\n    filesToProcess.forEach(filePath => {\n        const packageJson = fs.readFileSync(filePath, \"utf8\");\n        const sorted = sortPackageJson(packageJson);\n        if (sorted !== packageJson) {\n            fs.writeFileSync(filePath, sorted, \"utf8\");\n            console.log(`${filePath} is sorted!`);\n        }\n    });\n}\n","const versiony = require(\"versiony\");\nconst inquirer = require(\"inquirer\");\nconst prettier = require(\"prettier\");\nconst path = require(\"path\");\nconst chalk = require(\"chalk\");\nconst fs = require(\"fs\");\nconst sortPackageJson = require(\"./sort.js\");\nlet packagePath = path.resolve(process.cwd(), \"package.json\");\n\nif (!fs.existsSync(packagePath)) {\n    logError(\"Cannot find package.json file in the current directory\");\n    process.exit(1);\n}\n\nconst bump = async () => {\n    const type = await new Promise(resolve => {\n        inquirer\n            .prompt([\n                {\n                    type: \"list\",\n                    message: chalk.green.bold.underline(\"How big of a bump is this?\"),\n                    choices: [\"patch\", \"minor\", \"major\"],\n                    name: \"retType\"\n                }\n            ])\n            .then(async ({ retType }) => {\n                resolve(retType);\n            });\n    });\n\n    const vv = versiony.from(packagePath);\n    if (type === \"patch\") vv.patch();\n    if (type === \"minor\") vv.minor().patch(0);\n    if (type === \"major\") {\n        vv.major()\n            .patch(0)\n            .minor(0);\n    }\n    vv.to(packagePath).end();\n    let myFileContent = await fs.readFileSync(packagePath, \"utf8\");\n    let soPretty = \"\";\n    myFileContent = JSON.stringify(sortPackageJson(JSON.parse(myFileContent)));\n    try {\n        soPretty = prettier.format(myFileContent, {\n            printWidth: 20,\n            tabWidth: 4,\n            singleQuote: false,\n            trailingComma: \"none\",\n            bracketSpacing: true,\n            semi: true,\n            useTabs: true,\n            parser: \"json\",\n            jsxBracketSameLine: false // parser: \"json\",\n        });\n    } catch (e) {\n        console.info(\"-- Console ERR\", e);\n    }\n    await fs.writeFileSync(packagePath, soPretty, \"utf8\");\n};\n\nmodule.exports = bump;\n","const fs = require(\"fs-extra\");\nconst chalk = require(\"chalk\");\nconst boxen = require(\"boxen\");\nconst ONE_SIXTH = 1 / 6;\nconst ONE_THIRD = 1 / 3;\nconst TWO_THIRDS = 2 / 3;\nconst utils = {};\n\n/**\n * Output json file\n * @param f - file name with directory\n * @return {boolean}\n * @example\n const file = \"/tmp/this/path/does/not/exist/file.json\";\n removeFile(file);\n */\nutils.emptyDir = async f => {\n    try {\n        await fs.emptyDir(f);\n        // console.log(`${chalk.green.underline(\"Directory\")} ${chalk.bold(f)} emptied!`);\n    } catch (err) {\n        console.error(err);\n    }\n};\n\nconst desiredMode = 0o2775;\nconst defaultOptions = {\n    mode: desiredMode\n};\nutils.ensureDir = async (directory, options = defaultOptions) => {\n    try {\n        await fs.ensureDir(directory, options);\n    } catch (err) {\n        console.error(err);\n    }\n};\n\nutils.ensureFile = async f => {\n    try {\n        await fs.ensureFile(f);\n    } catch (err) {\n        console.error(err);\n    }\n};\n\n/**\n * Ensure path exists with dirs\n * @param f the file path\n * @return {boolean}\n * @example\n const file = \".fsr/config.json\";\n pathExists(file);\n */\nutils.pathExists = async f => {\n    const exists = await fs.pathExists(f);\n\n    return exists;\n};\n\n/**\n * Read json file\n * @param f - file name with directory\n * @return {Promise<void>}\n * @example\n const file = \"/tmp/this/path/does/not/exist/file.json\";\n outputJson(file);\n */\nutils.readJson = async f => {\n    try {\n        const packageObj = await fs.readJson(f);\n        // console.log(`${chalk.green.underline(\"File\")} ${chalk.bold(f)} read!`);\n        return packageObj;\n    } catch (err) {\n        console.error(err);\n        return {};\n    }\n};\n\nutils.readFile = async f => {\n    try {\n        let fl = await fs.readFileSync(f, \"utf8\");\n        return fl;\n    } catch (err) {\n        console.error(err);\n        return {};\n    }\n};\n\nutils.removeFile = async f => {\n    try {\n        // console.log(`${chalk.green.underline(\"File\")} ${chalk.bold(f)} removed!`);\n        return await fs.remove(f);\n    } catch (err) {\n        console.error(`File ${f} NOT REMOVED! ${err}`);\n        return false;\n    }\n};\n\n/**\n * Write file\n * @param f - file name with directory\n * @param contents - text inside the file\n * @return {Promise<void>}\n * @example\n const file = \"/tmp/this/path/does/not/exist/file.json\";\n writeFile(file);\n */\nutils.writeFile = async (f, contents = \"\") => {\n    try {\n        return fs.writeFileSync(f, contents, \"utf-8\");\n        // console.log(`${chalk.green.underline(\"File\")} ${chalk.bold(f)} written!`);\n    } catch (err) {\n        console.error(err);\n    }\n};\n\nutils.writeJson = async (f, json = {}) => {\n    try {\n        await fs.writeJson(f, json);\n        // console.log(`${chalk.green.underline(\"File\")} ${chalk.bold(f)} written!`);\n    } catch (err) {\n        console.error(err);\n    }\n};\n\nutils.chainAsync = fns => {\n    let curr = 0;\n    const last = fns[fns.length - 1];\n    const next = () => {\n        const fn = fns[curr++];\n        fn === last ? fn() : fn(next);\n    };\n    next();\n};\n\nutils.appendToFile = async (f, contents = \"\") => {\n    try {\n        await fs.appendFileSync(f, contents);\n    } catch (err) {\n        console.error(err);\n    }\n};\n\nutils.boxInform = async (\n    msg,\n    secondary = \"\",\n    padding = 0,\n    margin = { left: 2, top: 0, bottom: 0, right: 0 }\n) => {\n    console.log(\n        boxen(\n            chalk.hex(\"#717877\")(msg) +\n                \"\\n\" +\n                chalk.bold.underline.hex(\"#438b34\")(secondary) +\n                chalk.hex(\"#717877\")(\" \"),\n            {\n                padding,\n                margin,\n                borderStyle: {\n                    topLeft: chalk.hex(\"#5a596d\")(\"╔\"),\n                    topRight: chalk.hex(\"#5a596d\")(\"╗\"),\n                    bottomLeft: chalk.hex(\"#5a596d\")(\"╚\"),\n                    bottomRight: chalk.hex(\"#5a596d\")(\"╝\"),\n                    horizontal: chalk.hex(\"#5a596d\")(\"═\"),\n                    vertical: chalk.hex(\"#5a596d\")(\"║\")\n                }, //\"round\",\n                align: \"center\" //,\n            }\n        )\n    );\n};\n\nconst hue2rgb = (p, q, t) => {\n    if (t < 0) {\n        t += 1;\n    }\n    if (t > 1) {\n        t -= 1;\n    }\n    if (t < ONE_SIXTH) {\n        return p + (q - p) * 6 * t;\n    }\n    if (t < 0.5) {\n        return q;\n    }\n    if (t < TWO_THIRDS) {\n        return p + (q - p) * (TWO_THIRDS - t) * 6;\n    }\n    return p;\n};\n\nconst hsl2rgb = (h, s, l) => {\n    if (s === 0) {\n        return new Array(3).fill(l);\n    }\n    const q = l < 0.5 ? l * s + l : l + s - l * s;\n    const p = 2 * l - q;\n    return [hue2rgb(p, q, h + ONE_THIRD), hue2rgb(p, q, h), hue2rgb(p, q, h - ONE_THIRD)];\n};\n\nutils.rainbowGradient = (len, saturation = 1, lightness = 0.5) => {\n    const gradient = [];\n    for (let x = 0; x < len; x++) {\n        gradient.push(hsl2rgb(x / len, saturation, lightness).map(c => Math.round(c * 255)));\n    }\n    return gradient;\n};\n\n// utils.emptyDir = async () => {};\nmodule.exports = utils;\n","const chalk = require(\"chalk\");\nconst inquirer = require(\"inquirer\");\n\nconst { appendToFile, writeFile, boxInform, readJson, readFile } = require(\"./helpers.js\");\nconst path = require(\"path\");\nconst projectDir = process.cwd();\nconst packagePath = path.join(projectDir, \"package.json\");\n\nconst gen = { scripts: [] };\nlet mdfile = `# First category of scripts\n\nWelcome to your new amazing fscripts.md file. It replaces the headaches of npm scripts! But so much more.\n`;\n\ngen.init = async () => {\n    try {\n        gen.packageJson = await readJson(packagePath);\n        Object.keys(gen.packageJson.scripts).forEach(scriptName => {\n            mdfile += `\\n## ${scriptName}\\n\\n${\n                gen.packageJson.scripts[scriptName]\n            }\\n\\n\\`\\`\\`bash\\n${gen.packageJson.scripts[scriptName]}\\n\\`\\`\\`\\n\\n`;\n        });\n        await writeFile(\"./sample.fscripts.md\", mdfile);\n    } catch (err) {\n        console.error(err);\n    }\n};\n\nmodule.exports = gen.init;\n","\"use strict\";\nconst JoyCon = require(\"joycon\");\nconst path = require(\"path\");\nconst chalk = require(\"chalk\");\n\nconst joyRead = new JoyCon({\n    // Stop reading at parent dir\n    // i.e. Only read file from process.cwd()\n    stopDir: path.dirname(process.cwd())\n});\nconst flattenObject = (obj, prefix = \"\") =>\n    Object.keys(obj).reduce((acc, k) => {\n        const pre = prefix.length ? prefix + \".\" : \"\";\n        if (typeof obj[k] === \"object\") Object.assign(acc, flattenObject(obj[k], pre + k));\n        else acc[pre + k] = obj[k];\n        return acc;\n    }, {});\n\nconst marked = require(\"marked\");\n\nlet parse = function(mdContent) {\n    let js = marked.lexer(mdContent);\n    js = js.filter(e => e.type !== \"space\");\n\n    // let firstHeading = js.findIndex(e => e.type === \"heading\" && e.depth === 1); //?\n    let listMe = js.slice();\n    let tempItem = {};\n    let currentCategory = \"\";\n    let currentTask = \"\";\n    let taskOrder = 0;\n    listMe.forEach((item, indx) => {\n        if (item.type === \"heading\" && item.depth === 1) {\n            taskOrder = 0;\n            currentCategory = item.text;\n            tempItem[currentCategory] = { name: item.text, tasks: {}, description: \"\" };\n            let descriptor = js[indx + 1];\n            if (descriptor.type === \"paragraph\") {\n                tempItem[currentCategory].description = descriptor.text;\n            }\n        } else if (item.type === \"heading\" && item.depth === 2) {\n            currentTask = item.text;\n            tempItem[currentCategory].tasks[currentTask] = {\n                script: \"\",\n                name: currentTask,\n                description: \"\",\n                order: taskOrder\n            };\n            taskOrder++;\n            let descriptor = js[indx + 1];\n            let code = js[indx + 2];\n            if (descriptor.type === \"paragraph\" && code.type === \"code\") {\n                tempItem[currentCategory].tasks[currentTask].description = descriptor.text;\n                tempItem[currentCategory].tasks[currentTask].script = code.text;\n            } else if (descriptor.type === \"code\") {\n                tempItem[currentCategory].tasks[currentTask].script = descriptor.text;\n            }\n        }\n    });\n    let allTasks = [];\n    let categories = Object.keys(tempItem).map(catName => {\n        let ts = tempItem[catName].tasks;\n        let tasksArr = Object.keys(ts).map(tn => ts[tn]);\n        allTasks = [...allTasks, ...tasksArr];\n        return { name: catName, ...tempItem[catName] };\n    });\n    return { categories, allTasks };\n};\nconst parseScriptFile = async () => {\n    const { path: filepath, data } = joyRead.loadSync([\"fscripts.md\"]);\n    if (!filepath) {\n        //         console.warn(\n        //             `${chalk.bold.red(\"You're missing the fscripts.md file!\")}\n        // ${chalk.green(\"Please run 'fsr generate' to get started!\")}`\n        //         );\n        //\n        //         process.exit(0);\n        //         return null;\n        return false;\n    } else {\n        // console.warn(`${chalk.bold.green(\"Located fscripts.md file!\")}`);\n        let newContent = data.split(\"<!-- end toc -->\");\n        newContent = newContent[newContent.length === 2 ? 1 : 0];\n        return parse(newContent);\n    }\n};\n\nmodule.exports = parseScriptFile;\n","const path = require(\"path\");\nconst chalk = require(\"chalk\");\nrequire(\"markdown-toc\");\nconst JoyCon = require(\"joycon\");\nconst toc = require(\"markdown-toc\");\n\nconst joyRead = new JoyCon({\n    // Stop reading at parent dir\n    // i.e. Only read file from process.cwd()\n    stopDir: path.dirname(process.cwd())\n});\nconst { writeFile } = require(\"./helpers.js\");\n// const projectDir = process.cwd();\n\nconst generateToc = async () => {\n    const { path: filepath, data } = joyRead.loadSync([\"fscripts.md\"]);\n    if (!filepath) {\n        console.warn(\n            `${chalk.bold.red(\"You're missing the fscripts.md file!\")}\n${chalk.green(\"Please run 'fsr generate' to get started!\")}`\n        );\n        process.exit(0);\n        return null;\n    } else {\n        console.warn(`${chalk.bold.green(\"Located fscripts.md file!\")}`);\n        let newFile = ``;\n        let tocSplit = data.split(\"<!-- end toc -->\");\n        if (tocSplit.length === 2) {\n            newFile = toc(tocSplit[1]).content + \"\\n<!-- end toc -->\\n\\n\" + tocSplit[1].trim();\n        } else {\n            newFile = toc(data).content + \"\\n<!-- end toc -->\\n\\n\" + data.trim();\n        }\n        await writeFile(\"./fscripts.md\", newFile);\n    }\n};\n\nmodule.exports = generateToc;\n","#!/usr/bin/env node\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst childProcess = require(\"child_process\");\nconst chalk = require(\"chalk\");\nconst logError = message => {\n    console.log(chalk.red(\"[Error]: \" + message));\n};\nconst logInfo = message => {\n    console.log(chalk.blue(\"[Start]: \" + message));\n};\nconst logSuccess = message => {\n    console.log(chalk.green(\"[Done]: \" + message));\n};\n\nlet global = \"\";\nlet packagePath = path.resolve(process.cwd(), \"package.json\");\n\nif (!fs.existsSync(packagePath)) {\n    logError(\"Cannot find package.json file in the current directory\");\n    process.exit(1);\n}\n\nconst packageJson = require(packagePath);\nlet ignorePkgs = [];\nconst upgradePackages = async () => {\n    if (packageJson[\"fscripts\"]) {\n        if (packageJson[\"fscripts\"][\"ignore-upgrade\"]) {\n            ignorePkgs = packageJson[\"fscripts\"][\"ignore-upgrade\"];\n        }\n    }\n    let upgraded = { before: {}, after: {} };\n    for (let element of [\"dependencies\", \"devDependencies\", \"peerDependencies\"]) {\n        if (packageJson[element]) {\n            const packages = Object.keys(packageJson[element]);\n            let packagesList = packages\n                .filter(pkk => !ignorePkgs.includes(pkk))\n                .map(pkk => {\n                    upgraded[\"before\"][pkk] = packageJson[element][pkk];\n                    return pkk + \"@latest\";\n                })\n                .join(\" \");\n            let command = `yarn add ${packagesList}`;\n            try {\n                // logInfo(command);\n                childProcess.execSync(command, {\n                    stdio: \"inherit\",\n                    env: Object.assign({}, process.env, {\n                        FORCE_COLOR: true,\n                        PATH: `${path.resolve(\"node_modules\")}:${process.env.PATH}`\n                    })\n                });\n                const packageJsonAfter = JSON.parse(fs.readFileSync(packagePath));\n                const packagesAfter = Object.keys(packageJsonAfter[element]);\n                let packagesListAfter = packagesAfter\n                    .filter(pkk => !ignorePkgs.includes(pkk))\n                    .map(pkk => {\n                        upgraded[\"after\"][pkk] = packageJsonAfter[element][pkk];\n                        return upgraded[\"before\"][pkk] !== upgraded[\"after\"][pkk]\n                            ? `Updated: ${pkk} from: ${upgraded[\"before\"][pkk]} | to: ${\n                                  upgraded[\"after\"][pkk]\n                              }\\n`\n                            : ``;\n                    })\n                    .join(\"\");\n                logSuccess(packagesListAfter);\n            } catch (e) {\n                logError(`${command} - ${e}`);\n            }\n        }\n    }\n};\nmodule.exports = upgradePackages;\n","const chalk = require(\"chalk\");\nconst path = require(\"path\");\nconst moment = require(\"moment\");\nconst spawn = require(\"cross-spawn\");\n\nmodule.exports = async ({ script, task, type = script.type }, quiet = false) => {\n    if (!quiet) {\n        console.log(\n            `${chalk.green\n                .bgHex(\"#181c24\")\n                .bold(\"[\" + moment().format(\"HH:MM:SS\") + \"]\")}${chalk\n                .bgHex(\"#181c24\")\n                .bold.hex(\"#8c91a7\")(\" \" + task.name + \": \")}`\n        );\n    }\n    return new Promise(resolve => {\n        const cmd = spawn(type, [...script.rest], {\n            stdio: \"inherit\",\n            env: Object.assign({}, process.env, {\n                FORCE_COLOR: true,\n                PATH: `${path.resolve(\"node_modules/.bin\")}:${process.env.PATH}`\n            })\n        });\n\n        cmd.on(\"close\", code => {\n            if (code === 0) {\n                resolve();\n            } else {\n                console.error(`${chalk.red(\"ERROR\")} ${code}`);\n            }\n        });\n    });\n};\n","const runCLICommand = require(\"./runCLICommand\");\nconst chalk = require(\"chalk\");\n\nconst runSequence = async (tasks, FcScripts) => {\n    for (let t in tasks) {\n        let taskName = tasks[t];\n        let taskIndex = FcScripts.allTasks.findIndex(t => t.name === taskName);\n        if (taskIndex === -1) {\n            console.log(\n                `${chalk.red.underline(\n                    \"Skipping task \" + taskName + \", as it cannot be found in .md file\"\n                )}`\n            );\n        } else {\n            let script = FcScripts.allTasks[taskIndex].script;\n            let params = script.split(\" \");\n            let type = params.shift();\n            await runCLICommand({\n                task: { name: taskName },\n                script: {\n                    type: type,\n                    rest: params\n                }\n            });\n        }\n    }\n};\n\nmodule.exports = runSequence;\n// (async () => {\n//     await startScripts();\n// })();\n","const runCLICommand = require(\"./runCLICommand\");\n\nconst runParallel = async (tasks, FcScripts) => {\n    for (let t in tasks) {\n        let taskName = tasks[t];\n        let taskIndex = FcScripts.allTasks.findIndex(t => t.name === taskName);\n        let script = FcScripts.allTasks[taskIndex].script;\n        let params = script.split(\" \");\n        let type = params.shift();\n\n        runCLICommand({\n            task: { name: taskName },\n            script: {\n                type: type,\n                rest: params\n            }\n        });\n    }\n};\n\nmodule.exports = runParallel;\n","const inquirer = require(\"inquirer\");\nconst separator = \"   ~   \";\nconst chalk = require(\"chalk\");\nconst convertBold = arr => {\n    return arr.map(e => {\n        let reg = /(\\*\\*|^\\*\\*)(?=\\S)([\\s\\S]*?\\S)\\*\\*(?![\\*\\*\\S])/g;\n        let boldMatches = e.match(reg);\n        if (boldMatches !== null) {\n            boldMatches.forEach(m => {\n                e = e.replace(m, chalk.bold.redBright(m.replace(/\\*\\*/g, \" \"))); //.underline.bgBlack.whiteBright\n            });\n        }\n        let regunderline = /(_|^_)(?=\\S)([\\s\\S]*?\\S)_(?![_\\S])/g;\n        let underlineMatches = e.match(regunderline);\n        if (underlineMatches !== null) {\n            underlineMatches.forEach(m => {\n                e = e.replace(m, chalk.underline.greenBright(m.replace(/\\_\\_/g, \" \"))); //.underline.bgBlack.whiteBright\n            });\n        }\n        return e;\n    });\n};\nconst taskList = async (FcScripts, recentTasks) => {\n    return new Promise(resolve => {\n        let choiceCategories = [\n            ...recentTasks,\n            { name: \"-------------\", value: null },\n            ...FcScripts.categories.map(cat => {\n                return {\n                    name: `${chalk.bold.underline.green(cat.name)} ${separator} ${cat.description}`,\n                    value: cat.name\n                };\n            })\n        ];\n        inquirer\n            .prompt([\n                {\n                    type: \"list\",\n                    name: \"category\",\n                    message: \"What category do you want to run?\",\n                    choices: choiceCategories\n                }\n            ])\n            .then(({ category }) => {\n                let sepInd = choiceCategories.indexOf(\"-------------\");\n                let chosenInd = choiceCategories.indexOf(category);\n                if (category === null) {\n                    console.log(\"Can't select divider\");\n                } else if (chosenInd < sepInd) {\n                    let taskToRun = category.split(separator)[0].trim();\n                    resolve(taskToRun);\n                } else {\n                    let categoryName = category.split(separator)[0];\n                    let catObj = FcScripts.categories.findIndex(e => e.name === categoryName);\n                    catObj = FcScripts.categories[catObj];\n                    let taskNames = Object.keys(catObj.tasks).map(taskName => {\n                        let task = catObj.tasks[taskName];\n                        return `${taskName} ${\n                            task.description\n                                ? separator + task.description.replace(/\\n/g, \" \").trim()\n                                : \"\"\n                        }`;\n                    });\n                    taskNames = convertBold(taskNames);\n                    inquirer\n                        .prompt([\n                            {\n                                type: \"list\",\n                                name: \"taskToRun\",\n                                message: \"Which task do you want to run\",\n                                choices: taskNames\n                            }\n                        ])\n                        .then(({ taskToRun }) => {\n                            taskToRun = taskToRun.split(separator)[0].trim();\n                            resolve(taskToRun);\n                        });\n                }\n            });\n    });\n};\n\nmodule.exports = taskList;\n","\"use strict\";\nconst path = require(\"path\");\nconst chalk = require(\"chalk\");\nconst projectPath = path.join(process.cwd(), \"./package.json\");\nconst { readJson } = require(\"./helpers\");\nconst parseScriptFile = async () => {\n    const packageFile = await readJson(projectPath);\n    return packageFile.scripts;\n};\n\nmodule.exports = parseScriptFile;\n","const taskList = require(\"./taskList\");\nconst separator = \"   ~   \";\nconst Conf = require(\"conf\");\nconst config = new Conf();\nconst moment = require(\"moment\");\nconst chalk = require(\"chalk\");\nconst parseScriptFile = require(\"./parseScriptsMd.js\");\nconst parsePackageFile = require(\"./parseScriptsPackage.js\");\nconst runCLICommand = require(\"./runCLICommand\");\nconst { prompt } = require(\"enquirer\");\n\nconst taskListAutoComplete = async tasks => {\n    try {\n        let { answer } = await prompt({\n            type: \"autocomplete\",\n            message: `${chalk.green.bold.underline(\"Choose task to run\")}`,\n            choices: tasks,\n            name: `answer`\n        });\n        return answer.split(separator)[0].trim();\n    } catch (e) {\n        return false;\n    }\n};\n\nconst startScripts = async (categories = true) => {\n    console.clear();\n    const FcScripts = await parseScriptFile();\n    if (FcScripts === false) {\n        return false;\n    }\n    let recentTasks = config.get(\"recentTasks\", {});\n    let recentTaskArr = Object.keys(recentTasks)\n        .map(taskName => {\n            let task = recentTasks[taskName];\n            return { name: taskName, lastExecuted: task.lastExecuted };\n        })\n        .sort((a, b) =>\n            a.lastExecuted > b.lastExecuted ? 1 : b.lastExecuted > a.lastExecuted ? -1 : 0\n        )\n        .reverse()\n        .slice(0, 3);\n    let recentTaskOptions = recentTaskArr.map(task => {\n        return task.name + separator + moment(task.lastExecuted).calendar();\n    });\n    let taskToRun;\n    if (categories) {\n        taskToRun = await taskList(FcScripts, recentTaskOptions);\n    } else {\n        let tasks = FcScripts.allTasks;\n\n        taskToRun = await taskListAutoComplete(\n            tasks.map(task => {\n                return `${task.name}${separator}${task.description}`;\n            })\n        );\n    }\n    if (recentTasks[taskToRun] === undefined) {\n        recentTasks[taskToRun] = { lastExecuted: Date.now() };\n    } else {\n        recentTasks[taskToRun].lastExecuted = Date.now();\n    }\n    config.set(\"recentTasks\", recentTasks);\n    let taskIndex = FcScripts.allTasks.findIndex(t => t.name === taskToRun);\n    let script = FcScripts.allTasks[taskIndex].script;\n    let params = script.split(\" \");\n    let type = params.shift();\n    await runCLICommand({\n        task: { name: taskToRun },\n        script: {\n            type: type,\n            rest: params\n        }\n    });\n};\n\nconst startPackageScripts = async () => {\n    console.clear();\n    const packageScripts = await parsePackageFile();\n    let tasks = Object.keys(packageScripts).map(e => {\n        return { name: e, script: packageScripts[e] };\n    });\n\n    let taskToRun = await taskListAutoComplete(\n        tasks.map(task => {\n            return `${task.name}${separator}${task.script}`;\n        })\n    );\n    if (taskToRun === false) {\n        console.log(chalk.green.bold(\"See you soon!\"));\n        return false;\n    }\n    await runCLICommand({\n        task: { name: taskToRun },\n        script: {\n            type: \"yarn\",\n            rest: [taskToRun]\n        }\n    });\n};\n\nconst clearRecent = async () => {\n    config.set(\"recentTasks\", {});\n};\nmodule.exports = {\n    startScripts,\n    taskListAutoComplete,\n    clearRecent,\n    startPackageScripts\n};\n","const separator = \"   ~   \";\nconst chalk = require(\"chalk\");\n\nconst { prompt } = require(\"enquirer\");\nconst optionList = async () => {\n    let choiceCategories = [\n        {\n            name: \"start\",\n            message: \"Choose category then task to run\"\n        },\n        {\n            name: \"list\",\n            message: \"Select any task with text autocompletion\"\n        },\n        {\n            name: \"scripts\",\n            message: \"Choose a script from package.json\"\n        },\n        {\n            name: \"upgrade\",\n            message: \"Upgrade all your packages except ones specified by 'ignore-upgrade':[]\"\n        },\n        {\n            name: \"bump\",\n            message: \"Bump package.json and beautify it!\"\n        },\n        {\n            name: \"encryption\",\n            message: \"Encrypt/Decrypt secret files\"\n        },\n        {\n            name: \"clear\",\n            message: \"Clear recent task history\"\n        },\n        {\n            name: \"generate\",\n            message: \"Generate a sample fscripts.md file from the package.json\"\n        },\n        {\n            name: \"toc\",\n            message: \"Generate updated Table of Contents on top of the fscripts.md file\"\n        },\n        {\n            name: \"--help\",\n            message: \"See full help documentation\"\n        }\n    ];\n    try {\n        let { answer } = await prompt({\n            type: \"select\",\n            name: `answer`,\n            choiceMessage: e => {\n                // return JSON.stringify(e)\n                // return e.message;\n                return chalk.bold.underline.black(e.name + \":\" + chalk.gray(\" \" + e.message));\n            },\n            message: `${chalk.cyan.bold.underline(\"Whatz category do you want to run?\")}`,\n            choices: choiceCategories\n        });\n        return answer;\n    } catch (e) {\n        return false;\n    }\n};\n\nmodule.exports = optionList;\n","const inquirer = require(\"inquirer\");\nconst chalk = require(\"chalk\");\nconst boxen = require(\"boxen\");\nconst { boxInform } = require(\"../helpers.js\");\nconst git = require(\"git-state\");\nconst simple = require(\"simple-git\");\nconst pathToCwd = process.cwd();\n\nconst newBranch = async name => {\n    // const last = await new Promise(rzz => {\n    //     git.isGit(pathToCwd, function(exists) {\n    //         if (!exists) return;\n\n    //\n    //         git.commit(pathToCwd, function(err, result) {\n    //             if (err) throw err;\n    //             rzz(result);\n    //         });\n    //     });\n    // });\n\n    try {\n        // logInfo(command);\n       childProcess.execSync(\n            `git -c core.quotepath=false -c log.showSignature=false checkout -b ${name}`,\n            {\n                stdio: \"inherit\",\n                env: Object.assign({}, process.env, {\n                    FORCE_COLOR: true,\n                    PATH: `${path.resolve(\"node_modules\")}:${process.env.PATH}`\n                })\n            }\n        );\n    } catch (e) {}\n\n    // await simple().checkoutLocalBranch(name);\n    // await simple().checkoutBranch(name, \"origin\");\n    boxInform(chalk.green(`New branch ${name} created`, \"\", 5));\n};\n\nasync function pub() {\n    return new Promise(resolve => {\n        inquirer\n            .prompt([\n                {\n                    type: \"input\",\n                    message: chalk.bold.hex(\"#38be18\")(`Name new feature branch (or type cancel):`),\n                    name: \"branchname\"\n                }\n            ])\n            .then(async ({ branchname }) => {\n                if (branchname !== \"Development\") await newBranch(branchname);\n                resolve();\n            });\n    });\n}\n\nconst validateNotInDev = async () => {\n    await new Promise(async resolve => {\n        const git = require(\"simple-git/promise\");\n\n        let statusSummary = await git(__dirname).status();\n        if (statusSummary.current === \"Development\") {\n            console.clear();\n            console.log(\n                boxen(chalk.bold.underline.red(\"DO NO MAKE CHANGES IN DEV!\"), {\n                    padding: 2\n                })\n            );\n            await new Promise(resolve1 =>\n                setTimeout(() => {\n                    resolve1();\n                }, 1000)\n            );\n            await pub();\n            resolve();\n        } else {\n            resolve();\n        }\n    });\n};\nmodule.exports = validateNotInDev;\n","const CryptoJS = require(\"crypto-js\");\nconst chalk = require(\"chalk\");\nvar inquirer = require(\"inquirer\");\n\nconst {\n    appendToFile,\n    ensureFile,\n    writeFile,\n    boxInform,\n    readJson,\n    readFile\n} = require(\"../helpers.js\");\nconst path = require(\"path\");\nconst scriptsDir = process.cwd();\nconst rootDir = path.join(scriptsDir, \"./\");\nconst packagePath = path.join(rootDir, \"package.json\");\nconst igPath = path.join(rootDir, \".gitignore\");\nconst prettier = require(\"prettier\");\nconst encrypt = { encryptedFiles: [] };\n\n// prettier-ignore\nencrypt.encrypt = async (pass, encryptedFile, decryptedFile) => {\n    let willEncrypt = true;\n    let sureSure = await ensureFile(encryptedFile);\n    if (sureSure) {\n        console.log(`${chalk.bold.red(\"FILE ALREADY EXISTS ARE YOU SURE?\")}`);\n        willEncrypt = await new Promise(resolve => {\n            inquirer\n                .prompt([\n                    {\n                        type: \"confirm\",\n                        message: chalk.bold.hex(\"#38be18\")(`Sure? (y/n): `),\n                        name: \"sure\"\n                    }\n                ])\n                .then(({ sure }) => {\n                    resolve(sure);\n                });\n        });\n    }\n    if (willEncrypt) {\n        let toEncrypt = await readFile(decryptedFile);\n        const ciphertext = CryptoJS.AES.encrypt(toEncrypt, pass);\n        await writeFile(encryptedFile, ciphertext.toString());\n    }\n\n};\n// prettier-ignore\nencrypt.decrypt = async (pass, encryptedFileLocation, decryptedFileLocation) => {\n    // let encryptedFileLocation = path.join(rootDir,\".\"+encryptedFile);\n    // let decryptedFileLocation = path.join(rootDir,encryptedFile);\n    let willEncrypt = true;\n    let sureSure = await ensureFile(decryptedFileLocation);\n    if (sureSure) {\n        console.log(`${chalk.bold.red(\"FILE ALREADY EXISTS ARE YOU SURE?\")}`);\n        willEncrypt = await new Promise(resolve => {\n            inquirer\n                .prompt([\n                    {\n                        type: \"confirm\",\n                        message: chalk.bold.hex(\"#38be18\")(`Sure wanna override file ${decryptedFileLocation}? (y/n): `),\n                        name: \"sure\"\n                    }\n                ])\n                .then(({ sure }) => {\n                    resolve(sure);\n                });\n        });\n    }\n    if (willEncrypt) {\n        let toDecrypt = await readFile(encryptedFileLocation);\n        const bytes = CryptoJS.AES.decrypt(toDecrypt, pass);\n        let decryptedData;\n        try {\n            decryptedData = bytes.toString(CryptoJS.enc.Utf8);\n        } catch (e) {\n            console.error(\"-- Console Problem \", e);\n        }\n        await writeFile(decryptedFileLocation, decryptedData);\n        console.warn(`${chalk.bold.green.underline(\"DECRYPTED FILE:\")} ${chalk.bold.dim(path.join(scriptsDir, decryptedFileLocation))}`);\n    }\n\n};\n\nencrypt.init = async () => {\n    try {\n        let pass = await encrypt.getPass();\n        let toEncrypt = await encrypt.toEncrypt();\n        encrypt.packageJson = await readJson(packagePath);\n        encrypt.ignore = await readFile(igPath);\n        encrypt.ignoredFiles = encrypt.ignore.split(\"\\n\");\n        if (encrypt.packageJson.fscripts) {\n            if (encrypt.packageJson.fscripts.encryptedFiles) {\n                encrypt.encryptedFiles = encrypt.packageJson.fscripts.encryptedFiles;\n                let filesToAdd = \"\\n\";\n                for (const e of encrypt.encryptedFiles) {\n                    if (encrypt.ignoredFiles.indexOf(e) === -1) {\n                        filesToAdd += e + \"\\n\";\n                    }\n                    let file = e + \"\";\n                    let fileSplit = file.split(\"/\");\n                    let name = fileSplit.pop();\n                    let encryptedFile = fileSplit.slice();\n                    let decryptedFile = fileSplit.slice();\n                    encryptedFile.push(\".\" + name);\n                    encryptedFile = path.join(rootDir, encryptedFile.join(\"/\"));\n                    decryptedFile.push(name);\n                    decryptedFile = path.join(rootDir, decryptedFile.join(\"/\"));\n\n                    if (toEncrypt) {\n                        await encrypt.encrypt(pass, encryptedFile, decryptedFile);\n                    } else {\n                        await encrypt.decrypt(pass, encryptedFile, decryptedFile);\n                    }\n                }\n\n                if (filesToAdd.trim().length > 0) {\n                    await appendToFile(igPath, filesToAdd + \"\\n\");\n                    boxInform(\" Added files to .gitignore: \", filesToAdd);\n                }\n            }\n        }\n    } catch (err) {\n        console.error(err);\n    }\n};\n\nencrypt.getPass = async () => {\n    return await new Promise(resolve => {\n        inquirer\n            .prompt([\n                {\n                    type: \"password\",\n                    mask: chalk.underline(\" ●\"),\n                    message: chalk.bold.hex(\"#38be18\")(`Enter a SECRET key (same as pass app) : `),\n                    name: \"pass\"\n                }\n            ])\n            .then(({ pass }) => {\n                resolve(pass);\n            });\n    });\n};\nencrypt.toEncrypt = async () => {\n    return await new Promise(resolve => {\n        inquirer\n            .prompt([\n                {\n                    type: \"list\",\n                    message: chalk.bold.hex(\"#38be18\")(\"Which direction?\"),\n                    choices: [\"encrypt\", \"decrypt\"],\n                    name: \"encryptDecrypt\"\n                }\n            ])\n            .then(async ({ encryptDecrypt }) => {\n                resolve(encryptDecrypt === \"encrypt\");\n            });\n    });\n};\n\nmodule.exports = { ...encrypt };\n","#!/usr/bin/env node\nconst bump = require(\"./lib/release/bump.js\");\nconst chalk = require(\"chalk\");\nconst generateFScripts = require(\"./lib/generateFScripts.js\");\nconst parseScriptFile = require(\"./lib/parseScriptsMd.js\");\n// const parseScriptPackage = require(\"./lib/parseScriptsPackage\");\nconst generateToc = require(\"./lib/generateToc\");\nconst upgradePackages = require(\"./lib/upgradePackages\");\nconst runSequence = require(\"./lib/runSequence\");\nconst runParallel = require(\"./lib/runParallel\");\nconst runCLICommand = require(\"./lib/runCLICommand\");\nconst { startPackageScripts, startScripts, clearRecent } = require(\"./lib/startScripts.js\");\nconst taskName = chalk.rgb(39, 173, 96).bold.underline;\nconst textDescription = chalk.rgb(159, 161, 181);\nconst optionList = require(\"./lib/optionList\");\nconst validateNotInDev = require(\"./lib/git/validateNotDev.js\");\nconst encrypt = require(\"./lib/encryption/encryption\");\n\n(async () => {\n    const argv = require(\"yargs\")\n        .usage(\"Usage: $0 <command> [options]\")\n\n        /**\n         *  fsr\n         */\n        .command(\"\", \"Choose a script runner command\", yargs => {}, async function() {})\n        .example(`${taskName(\"$0\")}`, `${textDescription(\"Choose a script runner command\")}`)\n\n        /**\n         *  fsr\n         */\n        .command(\n            \"branch\",\n            \"Create new branch instead of Development\",\n            yargs => {},\n            async function() {\n                await validateNotInDev();\n            }\n        )\n        .example(`${taskName(\"$0\")}`, `${textDescription(\"Validates branch and creates new\")}`)\n\n        /**\n         * fsr\n         * start --\n         */\n        .command(\"start\", \"Choose category then task to run\", yargs => {}, async function() {\n            if ((await startScripts()) === false) {\n                await startPackageScripts();\n            }\n        })\n        .example(`${taskName(\"$0 start\")}`, `${textDescription(\"Open a task selection selector\")}`)\n\n        /**\n         * fsr\n         * scripts --\n         */\n        .command(\"scripts\", \"Choose a script from package.json\", yargs => {}, async function() {\n            await startPackageScripts();\n        })\n        .example(\n            `${taskName(\"$0 scripts\")}`,\n            `${textDescription(\"Choose a script from package.json\")}`\n        )\n\n        /**\n         * fsr\n         * list --\n         */\n        .command(\"list\", \"Select any task with text autocompletion\", () => {}, async function(\n            argv\n        ) {\n            await startScripts(false);\n            // const tasks = await scriptsParsed().allTasks;\n        })\n        .example(`${taskName(\"$0 list\")}`, `${textDescription(\"Show you all tasks you can run\")}`)\n\n        /**\n         * fsr\n         * run --\n         */\n        .command(\"run\", \"Run a specific task\", () => {}, async function(argv) {\n            let task = argv._[1];\n            const FcScripts = await parseScriptFile();\n            let taskIndex = FcScripts.allTasks.findIndex(t => t.name === task);\n            let taskData = FcScripts.allTasks[taskIndex];\n            let runCommand = taskData[\"script\"].split(\" \");\n            let type = runCommand.shift();\n            let params = runCommand.join(\" \");\n            let args = Object.keys(argv)\n                .filter(e => e !== \"_\" && e !== \"$0\")\n                .map(e => ` --${e}=${argv[e]}`);\n            params += \" \" + args.join(\" \");\n            await runCLICommand({\n                task: { name: task },\n                script: {\n                    type: type,\n                    rest: params.split(\" \")\n                }\n            });\n        })\n        .example(`${taskName(\"$0 run start:web\")}`, `${textDescription(\"Run task 'start:web'\")}`)\n\n        /**\n         * fsr\n         * upgrade --\n         */\n        .command(\n            \"upgrade\",\n            \"Upgrade all your packages except ones specified by 'ignore-upgrade':[]\",\n            () => {},\n            async function(argv) {\n                let task = argv._[1];\n                await upgradePackages();\n            }\n        )\n        .example(`${taskName(\"$0 upgrade\")}`, `${textDescription(\"Upgraded!\")}`)\n\n        /**\n         * fsr\n         * bump --\n         */\n        .command(\"bump\", \"Bump package.json and beautify it!\", () => {}, async function(argv) {\n            let task = argv._[1];\n            await bump();\n        })\n        .example(`${taskName(\"$0 bump\")}`, `${textDescription(\"BUMPED AND PRETTY!\")}`)\n\n        /**\n         * fsr\n         * run-s --\n         */\n        .command(\"run-s\", \"Run a set of tasks one after another\", () => {}, async function(argv) {\n            let tasks = argv._.slice();\n            tasks.shift();\n            const FcScripts = await parseScriptFile();\n            await runSequence(tasks, FcScripts);\n        })\n        .example(\n            `${taskName(\"$0 run-s start:web start:desktop\")}`,\n            `${textDescription(\"Run task 'start:web' and afterwards 'start:desktop'\")}`\n        )\n\n        /**\n         * fsr\n         * run-p --\n         */\n        .command(\"run-p\", \"Run tasks in parallel\", () => {}, async function(argv) {\n            let tasks = argv._.slice();\n            tasks.shift();\n            const FcScripts = await parseScriptFile();\n            await runParallel(tasks, FcScripts);\n        })\n        .example(\n            `${taskName(\"$0 run-p start:web start:desktop\")}`,\n            `${textDescription(\"Run task 'start:web' and at the same time 'start:desktop'\")}`\n        )\n\n        /**\n         * fsr\n         * encryption --\n         */\n        .command(\"encryption\", \"Encrypt/Decrypt secret files\", () => {}, async function(argv) {\n            await encrypt.init();\n        })\n        .example(\n            `${taskName(\"$0 encryption\")}`,\n            `${textDescription(\"Encrypt/Decrypt secret files\")}`\n        )\n\n        /**\n         * fsr\n         * clear --\n         */\n        .command(\"clear\", \"Clear recent task history\", () => {}, async function(argv) {\n            await clearRecent();\n        })\n        .example(`${taskName(\"$0 clear\")}`, `${textDescription(\"Clear your recently run tasks\")}`)\n        .command(\n            \"generate\",\n            \"Generate a sample fscripts.md file from the package.json\",\n            () => {},\n            async function(argv) {\n                await generateFScripts();\n            }\n        )\n        .example(\n            `${taskName(\"$0 generate\")}`,\n            `${textDescription(\n                \"Generates a sample.fscripts.md you can use as template for your fscripts file\"\n            )}`\n        )\n        .command(\n            \"toc\",\n            \"Generate updated Table of Contents on top of the fscripts.md file\",\n            () => {},\n            async function(argv) {\n                await generateToc();\n            }\n        )\n        .example(\n            `${taskName(\"$0 toc\")}`,\n            `${textDescription(\n                \"Generate updated Table of Contents on top of the fscripts.md file\"\n            )}`\n        ).argv;\n\n    if (argv._.length === 0) {\n        (async function() {\n            const choice = await optionList();\n            if (choice) {\n                await runCLICommand(\n                    { task: { name: choice }, script: { type: \"fsr\", rest: [choice] } },\n                    true\n                );\n            } else {\n                console.log(chalk.green.bold(\"See you soon!\"));\n            }\n        })();\n    }\n})();\n"]}