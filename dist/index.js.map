{"version":3,"sources":["lib/runCLICommand.js","lib/helpers.js","lib/generateFScripts.js","lib/parseScriptsMd.js","lib/taskList.js","index.js"],"names":["getStream","require","chalk","path","tryPath","process","cwd","moment","prettyMs","spawn","module","exports","script","task","type","console","log","green","bgHex","bold","format","hex","name","Promise","resolve","reject","rest","stdio","env","Object","assign","FORCE_COLOR","PATH","on","code","fs","boxen","ONE_SIXTH","ONE_THIRD","TWO_THIRDS","utils","emptyDir","f","err","error","desiredMode","defaultOptions","mode","ensureDir","directory","options","ensureFile","pathExists","exists","readJson","packageObj","readFile","fl","readFileSync","removeFile","remove","writeFile","contents","outputFile","writeJson","json","chainAsync","fns","curr","last","length","next","fn","appendToFile","appendFileSync","boxInform","msg","secondary","underline","padding","margin","left","top","bottom","right","borderStyle","topLeft","topRight","bottomLeft","bottomRight","horizontal","vertical","align","hue2rgb","p","q","t","hsl2rgb","h","s","l","Array","fill","rainbowGradient","len","saturation","lightness","gradient","x","push","map","c","Math","round","inquirer","projectDir","packagePath","join","gen","scripts","mdfile","init","packageJson","keys","forEach","scriptName","JoyCon","joyRead","stopDir","dirname","marked","parse","mdContent","js","lexer","filter","e","categories","tempItem","item","indx","title","depth","text","nxt","description","subitems","undefined","currTask","allTasks","cat","tasks","lang","parseScriptFile","filepath","data","loadSync","warn","newContent","replace","trim","red","mm","requireFromString","runCLICommand","getColonTimeFromDate","Date","toTimeString","slice","secretFilePath","separator","scriptsDir","rootDir","packageFileDir","FcScripts","constructor","opts","loadAsync","runTasks","taskNames","inParallel","all","taskName","runTask","runFile","throwWhenNoMatchedTask","maidfile","find","runTaskHooks","start","now","runScript","handleError","stack","checkTypes","res","src","default","catch","when","prefix","getHelp","patterns","concat","some","logger","magenta","relative","dim","split","v","runList","getList","types","taskList","recentTasks","choiceCategories","prompt","message","choices","then","category","sepInd","indexOf","chosenInd","taskToRun","categoryName","catObj","findIndex","generateFScripts","Conf","config","scriptsParsed","startScripts","get","recentTaskArr","recentTaskOptions","lastExecuted","sort","a","b","reverse","calendar","set","params","shift","argv","usage","example","rgb","command","yargs","_"],"mappings":"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","file":"index.js","sourceRoot":"..","sourcesContent":["const getStream = require(\"get-stream\");\nconst chalk = require(\"chalk\");\nconst path = require(\"path\");\n// const notifier = require(\"node-notifier\");\nconst tryPath = process.cwd();\nconst moment = require(\"moment\");\nconst prettyMs = require(\"pretty-ms\");\nconst spawn = require(\"cross-spawn\");\n\nmodule.exports = async ({ script, task, type = script.type }) => {\n    console.log(\n        `${chalk.green.bgHex(\"#181c24\").bold(moment().format(\"HH:MM:SS\") + \" executing \")}${chalk\n            .bgHex(\"#181c24\").bold\n            .hex(\"#8c91a7\")(task.name + \":\")} :`\n    );\n    return new Promise((resolve, reject) => {\n        const cmd = spawn(type, [...script.rest], {\n            stdio: \"inherit\",\n            env: Object.assign({}, process.env, {\n                FORCE_COLOR: true,\n                PATH: `${path.resolve(\"node_modules/.bin\")}:${process.env.PATH}`\n            })\n        });\n\n        cmd.on(\"close\", code => {\n            if (code === 0) {\n                resolve();\n            } else {\n                reject(\"ERROR --\");\n            }\n        });\n    });\n};\n","const fs = require(\"fs-extra\");\nconst chalk = require(\"chalk\");\nconst boxen = require(\"boxen\");\nconst ONE_SIXTH = 1 / 6;\nconst ONE_THIRD = 1 / 3;\nconst TWO_THIRDS = 2 / 3;\nconst utils = {};\n\n/**\n * Output json file\n * @param f - file name with directory\n * @return {boolean}\n * @example\n const file = \"/tmp/this/path/does/not/exist/file.json\";\n removeFile(file);\n */\nutils.emptyDir = async f => {\n    try {\n        await fs.emptyDir(f);\n        // console.log(`${chalk.green.underline(\"Directory\")} ${chalk.bold(f)} emptied!`);\n    } catch (err) {\n        console.error(err);\n    }\n};\n\nconst desiredMode = 0o2775;\nconst defaultOptions = {\n    mode: desiredMode\n};\nutils.ensureDir = async (directory, options = defaultOptions) => {\n    try {\n        await fs.ensureDir(directory, options);\n    } catch (err) {\n        console.error(err);\n    }\n};\n\nutils.ensureFile = async f => {\n    try {\n        await fs.ensureFile(f);\n    } catch (err) {\n        console.error(err);\n    }\n};\n\n/**\n * Ensure path exists with dirs\n * @param f the file path\n * @return {boolean}\n * @example\n const file = \".fsr/config.json\";\n pathExists(file);\n */\nutils.pathExists = async f => {\n    const exists = await fs.pathExists(f);\n\n    return exists;\n};\n\n/**\n * Read json file\n * @param f - file name with directory\n * @return {Promise<void>}\n * @example\n const file = \"/tmp/this/path/does/not/exist/file.json\";\n outputJson(file);\n */\nutils.readJson = async f => {\n    try {\n        const packageObj = await fs.readJson(f);\n        // console.log(`${chalk.green.underline(\"File\")} ${chalk.bold(f)} read!`);\n        return packageObj;\n    } catch (err) {\n        console.error(err);\n        return {};\n    }\n};\n\nutils.readFile = async f => {\n    try {\n        let fl = await fs.readFileSync(f, \"utf8\");\n        return fl;\n    } catch (err) {\n        console.error(err);\n        return {};\n    }\n};\n\nutils.removeFile = async f => {\n    try {\n        // console.log(`${chalk.green.underline(\"File\")} ${chalk.bold(f)} removed!`);\n        return await fs.remove(f);\n    } catch (err) {\n        console.error(`File ${f} NOT REMOVED! ${err}`);\n        return false;\n    }\n};\n\n/**\n * Write file\n * @param f - file name with directory\n * @param contents - text inside the file\n * @return {Promise<void>}\n * @example\n const file = \"/tmp/this/path/does/not/exist/file.json\";\n writeFile(file);\n */\nutils.writeFile = async (f, contents = \"\") => {\n    try {\n        return await fs.outputFile(f, contents);\n        // console.log(`${chalk.green.underline(\"File\")} ${chalk.bold(f)} written!`);\n    } catch (err) {\n        console.error(err);\n    }\n};\n\nutils.writeJson = async (f, json = {}) => {\n    try {\n        await fs.writeJson(f, json);\n        // console.log(`${chalk.green.underline(\"File\")} ${chalk.bold(f)} written!`);\n    } catch (err) {\n        console.error(err);\n    }\n};\n\nutils.chainAsync = fns => {\n    let curr = 0;\n    const last = fns[fns.length - 1];\n    const next = () => {\n        const fn = fns[curr++];\n        fn === last ? fn() : fn(next);\n    };\n    next();\n};\n\nutils.appendToFile = async (f, contents = \"\") => {\n    try {\n        await fs.appendFileSync(f, contents);\n    } catch (err) {\n        console.error(err);\n    }\n};\n\nutils.boxInform = async (msg, secondary = \"\") => {\n    console.log(\n        boxen(\n            chalk.hex(\"#717877\")(msg) +\n                chalk.bold.underline.hex(\"#438b34\")(secondary) +\n                chalk.hex(\"#717877\")(\" \"),\n            {\n                padding: 0,\n                margin: { left: 2, top: 0, bottom: 0, right: 0 },\n                borderStyle: {\n                    topLeft: chalk.hex(\"#5a596d\")(\"╔\"),\n                    topRight: chalk.hex(\"#5a596d\")(\"╗\"),\n                    bottomLeft: chalk.hex(\"#5a596d\")(\"╚\"),\n                    bottomRight: chalk.hex(\"#5a596d\")(\"╝\"),\n                    horizontal: chalk.hex(\"#5a596d\")(\"═\"),\n                    vertical: chalk.hex(\"#5a596d\")(\"║\")\n                }, //\"round\",\n                align: \"center\" //,\n            }\n        )\n    );\n};\n\nconst hue2rgb = (p, q, t) => {\n    if (t < 0) {\n        t += 1;\n    }\n    if (t > 1) {\n        t -= 1;\n    }\n    if (t < ONE_SIXTH) {\n        return p + (q - p) * 6 * t;\n    }\n    if (t < 0.5) {\n        return q;\n    }\n    if (t < TWO_THIRDS) {\n        return p + (q - p) * (TWO_THIRDS - t) * 6;\n    }\n    return p;\n};\n\nconst hsl2rgb = (h, s, l) => {\n    if (s === 0) {\n        return new Array(3).fill(l);\n    }\n    const q = l < 0.5 ? l * s + l : l + s - l * s;\n    const p = 2 * l - q;\n    return [hue2rgb(p, q, h + ONE_THIRD), hue2rgb(p, q, h), hue2rgb(p, q, h - ONE_THIRD)];\n};\n\nutils.rainbowGradient = (len, saturation = 1, lightness = 0.5) => {\n    const gradient = [];\n    for (let x = 0; x < len; x++) {\n        gradient.push(hsl2rgb(x / len, saturation, lightness).map(c => Math.round(c * 255)));\n    }\n    return gradient;\n};\n\n// utils.emptyDir = async () => {};\nmodule.exports = utils;\n","const chalk = require(\"chalk\");\nconst inquirer = require(\"inquirer\");\n\nconst { appendToFile, writeFile, boxInform, readJson, readFile } = require(\"./helpers.js\");\nconst path = require(\"path\");\nconst projectDir = process.cwd();\nconst packagePath = path.join(projectDir, \"package.json\");\n\nconst gen = { scripts: [] };\nlet mdfile =\n    \"# First category of scripts\\n\\n Welcome to your new amazing .fscripts.md file. It replaces the headaches of npm scripts! But so much more.\\n\\n\";\n\ngen.init = async () => {\n    try {\n        gen.packageJson = await readJson(packagePath);\n        Object.keys(gen.packageJson.scripts).forEach(scriptName => {\n            mdfile += `\\n## ${scriptName}\\n\\nTBD\\n\\n\\`\\`\\`bash\\n${\n                gen.packageJson.scripts[scriptName]\n            }\\n\\`\\`\\`\\n\\n`;\n        });\n        await writeFile(\"./sample.fscripts.md\", mdfile);\n    } catch (err) {\n        console.error(err);\n    }\n};\n\nmodule.exports = gen.init;\n","\"use strict\";\nconst fs = require(\"fs\");\nconst JoyCon = require(\"joycon\");\nconst path = require(\"path\");\nconst chalk = require(\"chalk\");\n\nconst joyRead = new JoyCon({\n    // Stop reading at parent dir\n    // i.e. Only read file from process.cwd()\n    stopDir: path.dirname(process.cwd())\n});\nconst marked = require(\"marked\");\n\nlet parse = function(mdContent) {\n    let js = marked.lexer(mdContent);\n\n    js = js.filter(e => e.type !== \"space\");\n\n    let categories = [];\n    let tempItem = {};\n    js.forEach((item, indx) => {\n        if (!tempItem.title && item.depth === 1) {\n            tempItem.title = item.text;\n            let nxt = js[indx + 1];\n            tempItem.description = nxt && nxt.type === \"paragraph\" ? nxt.text : \"\";\n            tempItem.subitems = [];\n        } else if (tempItem.title && item.depth === 1) {\n            categories.push(tempItem);\n            tempItem = {};\n            tempItem.title = item.text;\n            let nxt = js[indx + 1];\n            tempItem.description = nxt && nxt.type === \"paragraph\" ? nxt.text : \"\";\n            tempItem.subitems = [];\n        } else {\n            if (tempItem.subitems === undefined) {\n                tempItem.subitems = [];\n            }\n            tempItem.subitems.push(item);\n        }\n    });\n    categories.push(tempItem);\n    tempItem = {};\n    let currTask = false;\n    let allTasks = {};\n    categories.forEach(cat => {\n        cat.tasks = {};\n        cat.subitems.forEach(item => {\n            if (!tempItem.title && item.depth === 2) {\n                currTask = item.text;\n                cat.tasks[currTask] = {};\n            } else if (tempItem.title && item.depth === 2) {\n                currTask = item.text;\n                cat.tasks[currTask] = {};\n                allTasks[currTask] = {};\n            } else {\n                if (item.type === \"paragraph\" && cat.tasks[currTask] !== undefined) {\n                    cat.tasks[currTask][\"description\"] = item.text;\n                }\n                if (item.type === \"code\") {\n                    cat.tasks[currTask][\"code\"] = { type: item.lang, code: item.text };\n                    allTasks[currTask] = { script: item.text, type: item.lang };\n                }\n            }\n        });\n        delete cat.subitems;\n    });\n    return { categories, allTasks };\n};\nconst parseScriptFile = async () => {\n    const { path: filepath, data } = joyRead.loadSync([\"fscripts.md\"]);\n    if (!filepath) {\n        console.warn(`${chalk.bold.red(\"You're missing the fscripts.md file!\")}`);\n        return null;\n    } else {\n        console.warn(`${chalk.bold.green(\"Located fscripts.md file!\")}`);\n        let newContent = data.replace(/(<!-- toc -->(\\s|\\S)*?<!-- tocstop -->)/g, \"\").trim();\n\n        return parse(newContent);\n    }\n};\n\nmodule.exports = parseScriptFile;\n","const chalk = require(\"chalk\");\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst mm = require(\"micromatch\");\nconst requireFromString = require(\"require-from-string\");\nconst runCLICommand = require(\"./runCLICommand\");\nconst inquirer = require(\"inquirer\");\nconst moment = require(\"moment\");\nconst getColonTimeFromDate = () => new Date().toTimeString().slice(0, 8);\nconst secretFilePath = path.join(process.cwd(), \"./.secret.json\");\nconst separator = \"   ~   \";\nconst scriptsDir = process.cwd();\nconst rootDir = path.join(scriptsDir, \"./\");\nconst packageFileDir = path.join(scriptsDir, \"./package.json\");\n\nclass FcScripts {\n    constructor(opts = {}) {\n        // logger.clear();\n        // logger.setOptions({ quiet: opts.quiet });\n        return this.loadAsync(opts);\n    }\n\n    async runTasks(taskNames, inParallel) {\n        if (!taskNames || taskNames.length === 0) return;\n\n        if (inParallel) {\n            await Promise.all(\n                taskNames.map(taskName => {\n                    return this.runTask(taskName);\n                })\n            );\n        } else {\n            for (const taskName of taskNames) {\n                await this.runTask(taskName);\n            }\n        }\n    }\n\n    async runFile(taskName) {\n        await this.runTask(\"beforeAll\", false);\n        await this.runTask(taskName);\n        await this.runTask(\"afterAll\", false);\n    }\n\n    async runTask(taskName, throwWhenNoMatchedTask = true) {\n        const task =\n            taskName && this.maidfile && this.maidfile.tasks.find(task => task.name === taskName);\n\n        if (!task) {\n            if (throwWhenNoMatchedTask) {\n                console.log(`No task called \"${taskName}\" was found. Stop.`);\n            } else {\n                return;\n            }\n        }\n\n        await this.runTaskHooks(task, \"before\");\n\n        const start = Date.now();\n        console.log(\"Starting\", '\"' + task.name + '...\"');\n\n        for (const script of task.scripts) {\n            await this.runScript(script, task);\n        }\n        await this.runTaskHooks(task, \"after\");\n\n        console.log(\"Finished\", '\"' + task.name + ` after ${Date.now() - start} ms`);\n    }\n\n    runScript(script, task) {\n        return new Promise((resolve, reject) => {\n            const handleError = err => {\n                console.log(`Task '${task.name}' failed.\\n${err.stack}`);\n            };\n            if (checkTypes(script, [\"sh\", \"bash\"])) {\n                return runCLICommand({ script, task, resolve, reject });\n            }\n            if (checkTypes(script, [\"py\", \"python\"])) {\n                return runCLICommand({ type: \"python\", script, task, resolve, reject });\n            }\n            if (checkTypes(script, [\"js\", \"javascript\"])) {\n                let res;\n                try {\n                    res = requireFromString(script.src, this.maidfile.filepath);\n                } catch (err) {\n                    return handleError(err);\n                }\n                res = res.default || res;\n                return resolve(\n                    typeof res === \"function\" ? Promise.resolve(res()).catch(handleError) : res\n                );\n            }\n\n            return resolve();\n        });\n    }\n\n    async runTaskHooks(task, when) {\n        const prefix = when === \"before\" ? \"pre\" : \"post\";\n        const tasks = this.maidfile.tasks.filter(({ name }) => {\n            return name === `${prefix}${task.name}`;\n        });\n        await this.runTasks(tasks.map(task => task.name));\n        for (const item of task[when]) {\n            const { taskNames, inParallel } = item;\n            await this.runTasks(taskNames, inParallel);\n        }\n    }\n\n    getHelp(patterns) {\n        patterns = [].concat(patterns);\n        const tasks =\n            patterns.length > 0\n                ? this.maidfile.tasks.filter(task => {\n                      return mm.some(task.name, patterns);\n                  })\n                : this.maidfile.tasks;\n\n        if (tasks.length === 0) {\n            console.log(`No tasks for pattern \"${patterns.join(\" \")}\" was found. Stop.`);\n        }\n\n        logger.log(\n            `\\n  ${chalk.magenta.bold(\n                `Task${tasks.length > 1 ? \"s\" : \"\"} in ${path.relative(\n                    process.cwd(),\n                    this.maidfile.filepath\n                )}:`\n            )}\\n\\n` +\n                tasks\n                    .map(\n                        task =>\n                            `  ${chalk.bold(task.name)}\\n${chalk.dim(\n                                task.description\n                                    ? task.description\n                                          .split(\"\\n\")\n                                          .map(v => `      ${v.trim()}`)\n                                          .join(\"\\n\")\n                                    : \"      No description\"\n                            )}`\n                    )\n                    .join(\"\\n\\n\") +\n                \"\\n\"\n        );\n    }\n\n    runList(patterns) {}\n\n    getList() {\n        const tasks = this.maidfile.tasks;\n    }\n}\n\nfunction checkTypes(task, types) {\n    return types.some(type => type === task.type);\n}\n\nconst taskList = async (FcScripts, recentTasks) => {\n    return new Promise(resolve => {\n        let choiceCategories = [\n            ...recentTasks,\n            ...[\"-------------\"],\n            ...FcScripts.categories.map(cat => {\n                return cat.title + separator + cat.description;\n            })\n        ];\n        inquirer\n            .prompt([\n                {\n                    type: \"list\",\n                    name: \"category\",\n                    message: \"What category do you want to run?\",\n                    choices: choiceCategories\n                }\n            ])\n            .then(({ category }) => {\n                let sepInd = choiceCategories.indexOf(\"-------------\");\n                let chosenInd = choiceCategories.indexOf(category);\n                if (sepInd === chosenInd) {\n                    console.log(\"Can't select divider\");\n                } else if (chosenInd < sepInd) {\n                    let taskToRun = category.split(separator)[0].trim();\n                    resolve(taskToRun);\n                } else {\n                    let categoryName = category.split(separator)[0];\n                    let catObj = FcScripts.categories.findIndex(e => e.title === categoryName);\n                    catObj = FcScripts.categories[catObj];\n                    let taskNames = Object.keys(catObj.tasks).map(taskName => {\n                        let task = catObj.tasks[taskName];\n                        return `${taskName} ${\n                            task.description\n                                ? separator + task.description.replace(/\\n/g, \" \").trim()\n                                : \"\"\n                        }`;\n                    });\n                    inquirer\n                        .prompt([\n                            {\n                                type: \"list\",\n                                name: \"taskToRun\",\n                                message: \"Which task do you want to run\",\n                                choices: taskNames\n                            }\n                        ])\n                        .then(({ taskToRun }) => {\n                            taskToRun = taskToRun.split(separator)[0].trim();\n                            resolve(taskToRun);\n                        });\n                }\n            });\n    });\n};\n\nmodule.exports = taskList;\n","// #!/usr/bin/env node\n\nconst chalk = require(\"chalk\");\nconst moment = require(\"moment\");\nconst runCLICommand = require(\"./lib/runCLICommand.js\");\nconst generateFScripts = require(\"./lib/generateFScripts.js\");\nconst parseScriptFile = require(\"./lib/parseScriptsMd.js\");\nconst taskList = require(\"./lib/taskList\");\nconst path = require(\"path\");\nconst scriptsDir = process.cwd();\nconst rootDir = path.join(scriptsDir, \"./\");\nconst separator = \"   ~   \";\n\nconst Conf = require(\"conf\");\nconst config = new Conf();\n\nconst scriptsParsed = async () => {\n    const FcScripts = await parseScriptFile();\n    return FcScripts;\n};\n\nconst startScripts = async () => {\n    const FcScripts = await scriptsParsed();\n    const recentTasks = config.get(\"recentTasks\", {});\n    let recentTaskArr = Object.keys(recentTasks)\n        .map(taskName => {\n            let task = recentTasks[taskName];\n            return { name: taskName, lastExecuted: task.lastExecuted };\n        })\n        .sort((a, b) =>\n            a.lastExecuted > b.lastExecuted ? 1 : b.lastExecuted > a.lastExecuted ? -1 : 0\n        )\n        .reverse()\n        .slice(0, 3);\n    let recentTaskOptions = recentTaskArr.map(task => {\n        return task.name + separator + moment(task.lastExecuted).calendar();\n    });\n    let taskToRun = await taskList(FcScripts, recentTaskOptions);\n    // + separator + moment().format(\"MMMM Do YYYY, h:mm:ss a\")\n    if (recentTasks[taskToRun] === undefined) {\n        recentTasks[taskToRun] = { lastExecuted: Date.now() };\n    } else {\n        recentTasks[taskToRun].lastExecuted = Date.now();\n    }\n    config.set(\"recentTasks\", recentTasks);\n    let script = FcScripts.allTasks[taskToRun].script;\n    let params = script.split(\" \");\n    let type = params.shift();\n    await runCLICommand({\n        task: { name: taskToRun },\n        script: {\n            type: type,\n            rest: params\n        }\n    });\n};\n\nconst argv = require(\"yargs\")\n    .usage(\"Usage: $0 <command> [options]\")\n    .scriptName(\"yarn fsr\")\n    .example(\n        `${chalk.rgb(39, 173, 96)(\"$0\")}`,\n        `${chalk.rgb(159, 161, 181)(\"will open a task selection selector\")}`\n    )\n    .command(\"start\", \"Start the scripts!\", yargs => {}, async function() {\n        await startScripts();\n    })\n    .example(\n        `${chalk.rgb(39, 173, 96)(\"$0 start\")}`,\n        `${chalk.rgb(159, 161, 181)(\"will open a task selection selector\")}`\n    )\n    .command(\"run\", \"Run a specific task\", () => {}, async function(argv) {\n        let task = argv._[1];\n    })\n    .example(\n        `${chalk.rgb(39, 173, 96)(\"$0 run start:web\")}`,\n        `${chalk.rgb(159, 161, 181)(\"will run task 'start:web'\")}`\n    )\n    .command(\"run-s\", \"Series as a sequence\", () => {}, async function(argv) {\n        let tasks = argv._.slice();\n        tasks.shift();\n        const FcScripts = await parseScriptFile();\n\n        for (let t in tasks) {\n            let taskName = tasks[t];\n            let script = FcScripts.allTasks[taskName].script;\n            let params = script.split(\" \");\n            let type = params.shift();\n            await runCLICommand({\n                task: { name: taskName },\n                script: {\n                    type: type,\n                    rest: params\n                }\n            });\n        }\n    })\n    .example(\n        `${chalk.rgb(39, 173, 96)(\"$0 run-s start:web start:desktop\")}`,\n        `${chalk.rgb(159, 161, 181)(\"will run task 'start:web' and afterwards 'start:desktop'\")}`\n    )\n    .command(\"clear\", \"Clear history\", () => {}, async function(argv) {\n        let tasks = argv._.slice();\n        tasks.shift();\n        const FcScripts = await parseScriptFile();\n\n        for (let t in tasks) {\n            let taskName = tasks[t];\n            let script = FcScripts.allTasks[taskName].script;\n            let params = script.split(\" \");\n            let type = params.shift();\n            await runCLICommand({\n                task: { name: taskName },\n                script: {\n                    type: type,\n                    rest: params\n                }\n            });\n        }\n    })\n    .command(\"generate\", \"Clear history\", () => {}, async function(argv) {\n        await generateFScripts();\n    })\n    .command(\"run-p\", \"Run tasks in parallel\", () => {}, async function(argv) {\n        let tasks = argv._.slice();\n        tasks.shift();\n        const FcScripts = await parseScriptFile();\n\n        for (let t in tasks) {\n            let taskName = tasks[t];\n            console.warn(\"-- Console WHICH\", taskName, FcScripts.allTasks[taskName]);\n            let script = FcScripts.allTasks[taskName].script;\n            let params = script.split(\" \");\n            let type = params.shift();\n\n            runCLICommand({\n                task: { name: taskName },\n                script: {\n                    type: type,\n                    rest: params\n                }\n            });\n        }\n    })\n    .example(\n        `${chalk.rgb(39, 173, 96)(\"$0 run-p start:web start:desktop\")}`,\n        `${chalk.rgb(159, 161, 181)(\n            \"will run task 'start:web' and at the same time 'start:desktop'\"\n        )}`\n    ).argv;\n\nif (argv._.length === 0) {\n    (async function() {\n        await startScripts();\n    })();\n}\n"]}