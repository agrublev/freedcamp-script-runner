{"version":3,"sources":["lib/release/sort.js","lib/release/bump.js","lib/helpers.js","lib/generateFScripts.js","lib/parseScriptsMd.js","lib/generateToc.js","lib/upgradePackages.js","lib/runCLICommand.js","lib/runSequence.js","lib/runParallel.js","lib/taskList.js","lib/parseScriptsPackage.js","lib/startScripts.js","lib/optionList.js","lib/git/validateNotDev.js","lib/encryption/encryption.js","index.js"],"names":["sortObjectKeys","require","detectIndent","sortOrder","defaultNpmScripts","sortPackageJson","packageJson","options","determinedSortOrder","wasString","hasWindowsNewlines","endCharacters","indentLevel","indent","substr","newlineMatch","match","JSON","parse","prefixedScriptRegex","prefixableScripts","slice","sortSubKey","key","sortList","unique","Array","isArray","sort","filter","el","index","arr","indexOf","toSortKey","script","prefixOmitted","replace","includes","compareScriptKeys","a","b","aScript","bScript","scripts","Object","keys","forEach","push","result","stringify","module","exports","main","fs","process","argv","cwd","filePath","readFileSync","sorted","writeFileSync","console","log","versiony","inquirer","prettier","path","chalk","packagePath","resolve","existsSync","logError","exit","bump","shouldNotPretty","typeParam","shouldPretty","Promise","prompt","type","message","green","bold","underline","default","name","then","should","info","choices","retType","vv","from","patch","minor","major","to","end","myFileContent","soPretty","format","printWidth","tabWidth","singleQuote","trailingComma","bracketSpacing","semi","useTabs","parser","jsxBracketSameLine","e","boxen","ONE_SIXTH","ONE_THIRD","TWO_THIRDS","utils","emptyDir","f","err","error","desiredMode","defaultOptions","mode","ensureDir","directory","ensureFile","pathExists","exists","readJson","packageObj","readFile","fl","removeFile","remove","writeFile","contents","writeJson","json","chainAsync","fns","curr","last","length","next","fn","appendToFile","appendFileSync","boxInform","msg","secondary","padding","margin","left","top","bottom","right","hex","borderStyle","topLeft","topRight","bottomLeft","bottomRight","horizontal","vertical","align","hue2rgb","p","q","t","hsl2rgb","h","s","l","fill","rainbowGradient","len","saturation","lightness","gradient","x","map","c","Math","round","projectDir","join","gen","mdfile","init","scriptName","JoyCon","joyRead","stopDir","dirname","flattenObject","obj","prefix","reduce","acc","k","pre","assign","marked","mdContent","js","lexer","listMe","tempItem","currentCategory","currentTask","taskOrder","item","indx","depth","text","tasks","description","descriptor","order","code","allTasks","categories","catName","ts","tasksArr","tn","parseScriptFile","filepath","data","loadSync","newContent","split","toc","generateToc","warn","red","newFile","tocSplit","content","trim","childProcess","logInfo","blue","logSuccess","global","ignorePkgs","upgradePackages","upgraded","before","after","element","packagesList","command","pkk","execSync","stdio","env","FORCE_COLOR","PATH","packageJsonAfter","packagesListAfter","moment","spawn","task","quiet","bgHex","rest","on","runCLICommand","runSequence","FcScripts","taskName","taskIndex","findIndex","params","shift","runParallel","separator","convertBold","reg","boldMatches","m","redBright","regunderline","underlineMatches","greenBright","convertBoldArray","taskList","recentTasks","choiceCategories","cat","value","pageSize","category","taskToRun","categoryName","catObj","taskNames","projectPath","packageFile","Conf","config","parsePackageFile","taskListAutoComplete","answer","startScripts","clear","get","recentTaskOptions","lastExecuted","reverse","calendar","undefined","Date","now","set","startPackageScripts","packageScripts","clearRecent","optionList","choiceMessage","black","gray","cyan","git","simple","pathToCwd","newBranch","pub","branchname","validateNotInDev","__dirname","status","current","resolve1","setTimeout","CryptoJS","scriptsDir","rootDir","igPath","encrypt","encryptedFiles","pass","encryptedFile","decryptedFile","willEncrypt","sure","toEncrypt","ciphertext","AES","toString","encryptedFileLocation","decryptedFileLocation","toDecrypt","bytes","decrypt","decryptedData","enc","Utf8","dim","getPass","ignore","ignoredFiles","fscripts","filesToAdd","file","fileSplit","pop","mask","encryptDecrypt","generateFScripts","rgb","textDescription","usage","yargs","example","_","runCommand","pretty","choice"],"mappings":"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","file":"index.js","sourceRoot":"..","sourcesContent":["#!/usr/bin/env node\nconst sortObjectKeys = require(\"sort-object-keys\");\nconst detectIndent = require(\"detect-indent\");\n\nconst sortOrder = [\n    \"name\",\n    \"version\",\n    \"description\",\n    \"keywords\",\n    \"sideEffects\",\n    \"main\",\n    \"umd:main\",\n    \"unpkg\",\n    \"module\",\n    \"workspaces\",\n    \"scripts\",\n    \"betterScripts\",\n    \"fscripts\",\n    \"source\",\n    \"jsnext:main\",\n    \"browser\",\n    \"homepage\",\n    \"bugs\",\n    \"repository\",\n    \"private\",\n    \"license\",\n    \"author\",\n    \"contributors\",\n    \"files\",\n    \"types\",\n    \"typings\",\n    \"style\",\n    \"example\",\n    \"examplestyle\",\n    \"assets\",\n    \"bin\",\n    \"man\",\n    \"directories\",\n    \"husky\",\n    \"pre-commit\",\n    \"commitlint\",\n    \"lint-staged\",\n    \"config\",\n    \"nodemonConfig\",\n    \"browserify\",\n    \"babel\",\n    \"browserslist\",\n    \"xo\",\n    \"prettier\",\n    \"eslintConfig\",\n    \"eslintIgnore\",\n    \"stylelint\",\n    \"jest\",\n    \"dependencies\",\n    \"devDependencies\",\n    \"peerDependencies\",\n    \"bundledDependencies\",\n    \"bundleDependencies\",\n    \"optionalDependencies\",\n    \"flat\",\n    \"resolutions\",\n    \"engines\",\n    \"engineStrict\",\n    \"os\",\n    \"cpu\",\n    \"preferGlobal\",\n    \"publishConfig\"\n];\n// See https://docs.npmjs.com/misc/scripts\nconst defaultNpmScripts = [\n    \"install\",\n    \"pack\",\n    \"prepare\",\n    \"publish\",\n    \"restart\",\n    \"shrinkwrap\",\n    \"start\",\n    \"stop\",\n    \"test\",\n    \"uninstall\",\n    \"version\"\n];\n\nfunction sortPackageJson(packageJson, options = {}) {\n    const determinedSortOrder = options.sortOrder || sortOrder;\n    let wasString = false;\n    let hasWindowsNewlines = false;\n    let endCharacters = \"\";\n    let indentLevel = 2;\n    if (typeof packageJson === \"string\") {\n        wasString = true;\n        indentLevel = detectIndent(packageJson).indent;\n        if (packageJson.substr(-1) === \"\\n\") {\n            endCharacters = \"\\n\";\n        }\n        const newlineMatch = packageJson.match(/(\\r?\\n)/);\n        hasWindowsNewlines = (newlineMatch && newlineMatch[0]) === \"\\r\\n\";\n        packageJson = JSON.parse(packageJson);\n    }\n\n    const prefixedScriptRegex = /^(pre|post)(.)/;\n    const prefixableScripts = defaultNpmScripts.slice();\n    if (typeof packageJson.scripts === \"object\") {\n        Object.keys(packageJson.scripts).forEach(script => {\n            const prefixOmitted = script.replace(prefixedScriptRegex, \"$2\");\n            if (packageJson.scripts[prefixOmitted] && !prefixableScripts.includes(prefixOmitted)) {\n                prefixableScripts.push(prefixOmitted);\n            }\n        });\n    }\n\n    function sortSubKey(key, sortList, unique) {\n        if (Array.isArray(packageJson[key])) {\n            packageJson[key] = packageJson[key].sort();\n            if (unique) {\n                packageJson[key] = array_unique(packageJson[key]);\n            }\n            return;\n        }\n        if (typeof packageJson[key] === \"object\") {\n            packageJson[key] = sortObjectKeys(packageJson[key], sortList);\n        }\n    }\n    function toSortKey(script) {\n        const prefixOmitted = script.replace(prefixedScriptRegex, \"$2\");\n        if (prefixableScripts.includes(prefixOmitted)) {\n            return prefixOmitted;\n        }\n        return script;\n    }\n    /*             b\n     *       pre | * | post\n     *   pre  0  | - |  -\n     * a  *   +  | 0 |  -\n     *   post +  | + |  0\n     */\n    function compareScriptKeys(a, b) {\n        if (a === b) return 0;\n        const aScript = toSortKey(a);\n        const bScript = toSortKey(b);\n        if (aScript === bScript) {\n            // pre* is always smaller; post* is always bigger\n            // Covers: pre* vs. *; pre* vs. post*; * vs. post*\n            if (a === `pre${aScript}` || b === `post${bScript}`) return -1;\n            // The rest is bigger: * vs. *pre; *post vs. *pre; *post vs. *\n            return 1;\n        }\n        return aScript < bScript ? -1 : 1;\n    }\n    function array_unique(array) {\n        return array.filter((el, index, arr) => index == arr.indexOf(el));\n    }\n    sortSubKey(\"keywords\", null, true);\n    sortSubKey(\"homepage\");\n    sortSubKey(\"bugs\", [\"url\", \"email\"]);\n    sortSubKey(\"license\", [\"type\", \"url\"]);\n    sortSubKey(\"author\", [\"name\", \"email\", \"url\"]);\n    sortSubKey(\"bin\");\n    sortSubKey(\"man\");\n    sortSubKey(\"directories\", [\"lib\", \"bin\", \"man\", \"doc\", \"example\"]);\n    sortSubKey(\"repository\", [\"type\", \"url\"]);\n    sortSubKey(\"scripts\", compareScriptKeys);\n    sortSubKey(\"betterScripts\", compareScriptKeys);\n    sortSubKey(\"commitlint\");\n    sortSubKey(\"lint-staged\");\n    sortSubKey(\"config\");\n    sortSubKey(\"nodemonConfig\");\n    sortSubKey(\"browserify\");\n    sortSubKey(\"babel\");\n    sortSubKey(\"eslintConfig\");\n    sortSubKey(\"jest\");\n    sortSubKey(\"xo\");\n    sortSubKey(\"prettier\");\n    sortSubKey(\"dependencies\");\n    sortSubKey(\"devDependencies\");\n    sortSubKey(\"peerDependencies\");\n    sortSubKey(\"bundledDependencies\");\n    sortSubKey(\"bundleDependencies\");\n    sortSubKey(\"optionalDependencies\");\n    sortSubKey(\"resolutions\");\n    sortSubKey(\"engines\");\n    sortSubKey(\"engineStrict\");\n    sortSubKey(\"os\");\n    sortSubKey(\"cpu\");\n    sortSubKey(\"preferGlobal\");\n    sortSubKey(\"private\");\n    sortSubKey(\"publishConfig\");\n    packageJson = sortObjectKeys(packageJson, determinedSortOrder);\n    if (wasString) {\n        let result = JSON.stringify(packageJson, null, indentLevel) + endCharacters;\n        if (hasWindowsNewlines) {\n            result = result.replace(/\\n/g, \"\\r\\n\");\n        }\n        return result;\n    }\n    return packageJson;\n}\nmodule.exports = sortPackageJson;\nmodule.exports.sortPackageJson = sortPackageJson;\nmodule.exports.sortOrder = sortOrder;\n\nif (require.main === module) {\n    const fs = require(\"fs\");\n\n    const filesToProcess = process.argv[2]\n        ? process.argv.slice(2)\n        : [`${process.cwd()}/package.json`];\n\n    filesToProcess.forEach(filePath => {\n        const packageJson = fs.readFileSync(filePath, \"utf8\");\n        const sorted = sortPackageJson(packageJson);\n        if (sorted !== packageJson) {\n            fs.writeFileSync(filePath, sorted, \"utf8\");\n            console.log(`${filePath} is sorted!`);\n        }\n    });\n}\n","#!/usr/bin/env node\nconst versiony = require(\"versiony\");\nconst inquirer = require(\"inquirer\");\nconst prettier = require(\"prettier\");\nconst path = require(\"path\");\nconst chalk = require(\"chalk\");\nconst fs = require(\"fs\");\nconst sortPackageJson = require(\"./sort.js\");\nlet packagePath = path.resolve(process.cwd(), \"package.json\");\n\nif (!fs.existsSync(packagePath)) {\n    logError(\"Cannot find package.json file in the current directory\");\n    process.exit(1);\n}\n\nconst bump = async (shouldNotPretty = false, typeParam = null) => {\n    let shouldPretty = true;\n    if (!shouldNotPretty) {\n        shouldPretty = await new Promise(resolve => {\n            inquirer\n                .prompt([\n                    {\n                        type: \"confirm\",\n                        message:\n                            chalk.green.bold.underline(\n                                \"Prettify JSON file? Will re-order all lines alphabetically\\n\"\n                            ) + \"(Default is no)\",\n                        default: false,\n                        name: \"should\"\n                    }\n                ])\n                .then(async ({ should }) => {\n                    console.info(\"--- INFO shou\", should);\n                    resolve(should);\n                });\n        });\n    }\n    let type = \"patch\";\n    if (!typeParam) {\n        let type = await new Promise(resolve => {\n            inquirer\n                .prompt([\n                    {\n                        type: \"list\",\n                        message: chalk.green.bold.underline(\"How big of a bump is this?\"),\n                        choices: [\"patch\", \"minor\", \"major\"],\n                        name: \"retType\"\n                    }\n                ])\n                .then(async ({ retType }) => {\n                    resolve(retType);\n                });\n        });\n    } else {\n        type = typeParam;\n    }\n    const vv = versiony.from(packagePath);\n    if (type === \"patch\") vv.patch();\n    if (type === \"minor\") vv.minor().patch(0);\n    if (type === \"major\") {\n        vv.major()\n            .patch(0)\n            .minor(0);\n    }\n    vv.to(packagePath).end();\n    console.info(\"--- INFO shouldPretty || shouldNotPretty\", shouldPretty || !shouldNotPretty);\n    if (!shouldPretty || !shouldNotPretty) {\n        let myFileContent = await fs.readFileSync(packagePath, \"utf8\");\n        let soPretty = myFileContent;\n        myFileContent = JSON.stringify(sortPackageJson(JSON.parse(myFileContent)));\n        try {\n            soPretty = prettier.format(myFileContent, {\n                printWidth: 20,\n                tabWidth: 4,\n                singleQuote: false,\n                trailingComma: \"none\",\n                bracketSpacing: true,\n                semi: true,\n                useTabs: true,\n                parser: \"json\",\n                jsxBracketSameLine: false // parser: \"json\",\n            });\n        } catch (e) {\n            console.info(\"-- Console ERR\", e);\n        }\n        await fs.writeFileSync(packagePath, soPretty, \"utf8\");\n    }\n};\n\nmodule.exports = bump;\n","const fs = require(\"fs-extra\");\nconst chalk = require(\"chalk\");\nconst boxen = require(\"boxen\");\nconst ONE_SIXTH = 1 / 6;\nconst ONE_THIRD = 1 / 3;\nconst TWO_THIRDS = 2 / 3;\nconst utils = {};\n\n/**\n * Output json file\n * @param f - file name with directory\n * @return {boolean}\n * @example\n const file = \"/tmp/this/path/does/not/exist/file.json\";\n removeFile(file);\n */\nutils.emptyDir = async f => {\n    try {\n        await fs.emptyDir(f);\n        // console.log(`${chalk.green.underline(\"Directory\")} ${chalk.bold(f)} emptied!`);\n    } catch (err) {\n        console.error(err);\n    }\n};\n\nconst desiredMode = 0o2775;\nconst defaultOptions = {\n    mode: desiredMode\n};\nutils.ensureDir = async (directory, options = defaultOptions) => {\n    try {\n        await fs.ensureDir(directory, options);\n    } catch (err) {\n        console.error(err);\n    }\n};\n\nutils.ensureFile = async f => {\n    try {\n        await fs.ensureFile(f);\n    } catch (err) {\n        console.error(err);\n    }\n};\n\n/**\n * Ensure path exists with dirs\n * @param f the file path\n * @return {boolean}\n * @example\n const file = \".fsr/config.json\";\n pathExists(file);\n */\nutils.pathExists = async f => {\n    const exists = await fs.pathExists(f);\n\n    return exists;\n};\n\n/**\n * Read json file\n * @param f - file name with directory\n * @return {Promise<void>}\n * @example\n const file = \"/tmp/this/path/does/not/exist/file.json\";\n outputJson(file);\n */\nutils.readJson = async f => {\n    try {\n        const packageObj = await fs.readJson(f);\n        // console.log(`${chalk.green.underline(\"File\")} ${chalk.bold(f)} read!`);\n        return packageObj;\n    } catch (err) {\n        console.error(err);\n        return {};\n    }\n};\n\nutils.readFile = async f => {\n    try {\n        let fl = await fs.readFileSync(f, \"utf8\");\n        return fl;\n    } catch (err) {\n        console.error(err);\n        return {};\n    }\n};\n\nutils.removeFile = async f => {\n    try {\n        // console.log(`${chalk.green.underline(\"File\")} ${chalk.bold(f)} removed!`);\n        return await fs.remove(f);\n    } catch (err) {\n        console.error(`File ${f} NOT REMOVED! ${err}`);\n        return false;\n    }\n};\n\n/**\n * Write file\n * @param f - file name with directory\n * @param contents - text inside the file\n * @return {Promise<void>}\n * @example\n const file = \"/tmp/this/path/does/not/exist/file.json\";\n writeFile(file);\n */\nutils.writeFile = async (f, contents = \"\") => {\n    try {\n        return fs.writeFileSync(f, contents, \"utf-8\");\n        // console.log(`${chalk.green.underline(\"File\")} ${chalk.bold(f)} written!`);\n    } catch (err) {\n        console.error(err);\n    }\n};\n\nutils.writeJson = async (f, json = {}) => {\n    try {\n        await fs.writeJson(f, json);\n        // console.log(`${chalk.green.underline(\"File\")} ${chalk.bold(f)} written!`);\n    } catch (err) {\n        console.error(err);\n    }\n};\n\nutils.chainAsync = fns => {\n    let curr = 0;\n    const last = fns[fns.length - 1];\n    const next = () => {\n        const fn = fns[curr++];\n        fn === last ? fn() : fn(next);\n    };\n    next();\n};\n\nutils.appendToFile = async (f, contents = \"\") => {\n    try {\n        await fs.appendFileSync(f, contents);\n    } catch (err) {\n        console.error(err);\n    }\n};\n\nutils.boxInform = async (\n    msg,\n    secondary = \"\",\n    padding = 0,\n    margin = { left: 2, top: 0, bottom: 0, right: 0 }\n) => {\n    console.log(\n        boxen(\n            chalk.hex(\"#717877\")(msg) +\n                \"\\n\" +\n                chalk.bold.underline.hex(\"#438b34\")(secondary) +\n                chalk.hex(\"#717877\")(\" \"),\n            {\n                padding,\n                margin,\n                borderStyle: {\n                    topLeft: chalk.hex(\"#5a596d\")(\"╔\"),\n                    topRight: chalk.hex(\"#5a596d\")(\"╗\"),\n                    bottomLeft: chalk.hex(\"#5a596d\")(\"╚\"),\n                    bottomRight: chalk.hex(\"#5a596d\")(\"╝\"),\n                    horizontal: chalk.hex(\"#5a596d\")(\"═\"),\n                    vertical: chalk.hex(\"#5a596d\")(\"║\")\n                }, //\"round\",\n                align: \"center\" //,\n            }\n        )\n    );\n};\n\nconst hue2rgb = (p, q, t) => {\n    if (t < 0) {\n        t += 1;\n    }\n    if (t > 1) {\n        t -= 1;\n    }\n    if (t < ONE_SIXTH) {\n        return p + (q - p) * 6 * t;\n    }\n    if (t < 0.5) {\n        return q;\n    }\n    if (t < TWO_THIRDS) {\n        return p + (q - p) * (TWO_THIRDS - t) * 6;\n    }\n    return p;\n};\n\nconst hsl2rgb = (h, s, l) => {\n    if (s === 0) {\n        return new Array(3).fill(l);\n    }\n    const q = l < 0.5 ? l * s + l : l + s - l * s;\n    const p = 2 * l - q;\n    return [hue2rgb(p, q, h + ONE_THIRD), hue2rgb(p, q, h), hue2rgb(p, q, h - ONE_THIRD)];\n};\n\nutils.rainbowGradient = (len, saturation = 1, lightness = 0.5) => {\n    const gradient = [];\n    for (let x = 0; x < len; x++) {\n        gradient.push(hsl2rgb(x / len, saturation, lightness).map(c => Math.round(c * 255)));\n    }\n    return gradient;\n};\n\n// utils.emptyDir = async () => {};\nmodule.exports = utils;\n","const chalk = require(\"chalk\");\nconst inquirer = require(\"inquirer\");\n\nconst { appendToFile, writeFile, boxInform, readJson, readFile } = require(\"./helpers.js\");\nconst path = require(\"path\");\nconst projectDir = process.cwd();\nconst packagePath = path.join(projectDir, \"package.json\");\n\nconst gen = { scripts: [] };\nlet mdfile = `# First category of scripts\n\nWelcome to your new amazing fscripts.md file. It replaces the headaches of npm scripts! But so much more.\n`;\n\ngen.init = async () => {\n    try {\n        gen.packageJson = await readJson(packagePath);\n        Object.keys(gen.packageJson.scripts).forEach(scriptName => {\n            mdfile += `\\n## ${scriptName}\\n\\n${\n                gen.packageJson.scripts[scriptName]\n            }\\n\\n\\`\\`\\`bash\\n${gen.packageJson.scripts[scriptName]}\\n\\`\\`\\`\\n\\n`;\n        });\n        await writeFile(\"./sample.fscripts.md\", mdfile);\n    } catch (err) {\n        console.error(err);\n    }\n};\n\nmodule.exports = gen.init;\n","\"use strict\";\nconst JoyCon = require(\"joycon\");\nconst path = require(\"path\");\nconst chalk = require(\"chalk\");\n\nconst joyRead = new JoyCon({\n    // Stop reading at parent dir\n    // i.e. Only read file from process.cwd()\n    stopDir: path.dirname(process.cwd())\n});\nconst flattenObject = (obj, prefix = \"\") =>\n    Object.keys(obj).reduce((acc, k) => {\n        const pre = prefix.length ? prefix + \".\" : \"\";\n        if (typeof obj[k] === \"object\") Object.assign(acc, flattenObject(obj[k], pre + k));\n        else acc[pre + k] = obj[k];\n        return acc;\n    }, {});\n\nconst marked = require(\"marked\");\n\nlet parse = function(mdContent) {\n    let js = marked.lexer(mdContent);\n    js = js.filter(e => e.type !== \"space\");\n\n    // let firstHeading = js.findIndex(e => e.type === \"heading\" && e.depth === 1); //?\n    let listMe = js.slice();\n    let tempItem = {};\n    let currentCategory = \"\";\n    let currentTask = \"\";\n    let taskOrder = 0;\n    listMe.forEach((item, indx) => {\n        if (item.type === \"heading\" && item.depth === 1) {\n            taskOrder = 0;\n            currentCategory = item.text;\n            tempItem[currentCategory] = { name: item.text, tasks: {}, description: \"\" };\n            let descriptor = js[indx + 1];\n            if (descriptor.type === \"paragraph\") {\n                tempItem[currentCategory].description = descriptor.text;\n            }\n        } else if (item.type === \"heading\" && item.depth === 2) {\n            currentTask = item.text;\n            tempItem[currentCategory].tasks[currentTask] = {\n                script: \"\",\n                name: currentTask,\n                description: \"\",\n                order: taskOrder\n            };\n            taskOrder++;\n            let descriptor = js[indx + 1];\n            let code = js[indx + 2];\n            if (descriptor.type === \"paragraph\" && code.type === \"code\") {\n                tempItem[currentCategory].tasks[currentTask].description = descriptor.text;\n                tempItem[currentCategory].tasks[currentTask].script = code.text;\n            } else if (descriptor.type === \"code\") {\n                tempItem[currentCategory].tasks[currentTask].script = descriptor.text;\n            }\n        }\n    });\n    let allTasks = [];\n    let categories = Object.keys(tempItem).map(catName => {\n        let ts = tempItem[catName].tasks;\n        let tasksArr = Object.keys(ts).map(tn => ts[tn]);\n        allTasks = [...allTasks, ...tasksArr];\n        return { name: catName, ...tempItem[catName] };\n    });\n    return { categories, allTasks };\n};\nconst parseScriptFile = async () => {\n    const { path: filepath, data } = joyRead.loadSync([\"fscripts.md\"]);\n    if (!filepath) {\n        //         console.warn(\n        //             `${chalk.bold.red(\"You're missing the fscripts.md file!\")}\n        // ${chalk.green(\"Please run 'fsr generate' to get started!\")}`\n        //         );\n        //\n        //         process.exit(0);\n        //         return null;\n        return false;\n    } else {\n        // console.warn(`${chalk.bold.green(\"Located fscripts.md file!\")}`);\n        let newContent = data.split(\"<!-- end toc -->\");\n        newContent = newContent[newContent.length === 2 ? 1 : 0];\n        return parse(newContent);\n    }\n};\n\nmodule.exports = parseScriptFile;\n","const path = require(\"path\");\nconst chalk = require(\"chalk\");\nrequire(\"markdown-toc\");\nconst JoyCon = require(\"joycon\");\nconst toc = require(\"markdown-toc\");\n\nconst joyRead = new JoyCon({\n    // Stop reading at parent dir\n    // i.e. Only read file from process.cwd()\n    stopDir: path.dirname(process.cwd())\n});\nconst { writeFile } = require(\"./helpers.js\");\n// const projectDir = process.cwd();\n\nconst generateToc = async () => {\n    const { path: filepath, data } = joyRead.loadSync([\"fscripts.md\"]);\n    if (!filepath) {\n        console.warn(\n            `${chalk.bold.red(\"You're missing the fscripts.md file!\")}\n${chalk.green(\"Please run 'fsr generate' to get started!\")}`\n        );\n        process.exit(0);\n        return null;\n    } else {\n        console.warn(`${chalk.bold.green(\"Located fscripts.md file!\")}`);\n        let newFile = ``;\n        let tocSplit = data.split(\"<!-- end toc -->\");\n        if (tocSplit.length === 2) {\n            newFile = toc(tocSplit[1]).content + \"\\n<!-- end toc -->\\n\\n\" + tocSplit[1].trim();\n        } else {\n            newFile = toc(data).content + \"\\n<!-- end toc -->\\n\\n\" + data.trim();\n        }\n        await writeFile(\"./fscripts.md\", newFile);\n    }\n};\n\nmodule.exports = generateToc;\n","const fs = require(\"fs\");\nconst path = require(\"path\");\nconst childProcess = require(\"child_process\");\nconst chalk = require(\"chalk\");\nconst logError = message => {\n    console.log(chalk.red(\"[Error]: \" + message));\n};\nconst logInfo = message => {\n    console.log(chalk.blue(\"[Start]: \" + message));\n};\nconst logSuccess = message => {\n    console.log(chalk.green(\"[Done]: \" + message));\n};\n\nlet global = \"\";\nlet packagePath = path.resolve(process.cwd(), \"package.json\");\n\nif (!fs.existsSync(packagePath)) {\n    logError(\"Cannot find package.json file in the current directory\");\n    process.exit(1);\n}\n\nconst packageJson = require(packagePath);\nlet ignorePkgs = [];\nconst upgradePackages = async () => {\n    if (packageJson[\"fscripts\"]) {\n        if (packageJson[\"fscripts\"][\"ignore-upgrade\"]) {\n            ignorePkgs = packageJson[\"fscripts\"][\"ignore-upgrade\"];\n        }\n    }\n    let upgraded = { before: {}, after: {} };\n    for (let element of [\"dependencies\", \"devDependencies\", \"peerDependencies\"]) {\n        if (packageJson[element]) {\n            const packages = Object.keys(packageJson[element]);\n            let packagesList = packages\n                .filter(pkk => !ignorePkgs.includes(pkk))\n                .map(pkk => {\n                    upgraded[\"before\"][pkk] = packageJson[element][pkk];\n                    return pkk + \"@latest\";\n                })\n                .join(\" \");\n            let command = `yarn add ${packagesList}`;\n            try {\n                // logInfo(command);\n                childProcess.execSync(command, {\n                    stdio: \"inherit\",\n                    env: Object.assign({}, process.env, {\n                        FORCE_COLOR: true,\n                        PATH: `${path.resolve(\"node_modules\")}:${process.env.PATH}`\n                    })\n                });\n                const packageJsonAfter = JSON.parse(fs.readFileSync(packagePath));\n                const packagesAfter = Object.keys(packageJsonAfter[element]);\n                let packagesListAfter = packagesAfter\n                    .filter(pkk => !ignorePkgs.includes(pkk))\n                    .map(pkk => {\n                        upgraded[\"after\"][pkk] = packageJsonAfter[element][pkk];\n                        return upgraded[\"before\"][pkk] !== upgraded[\"after\"][pkk]\n                            ? `Updated: ${pkk} from: ${upgraded[\"before\"][pkk]} | to: ${\n                                  upgraded[\"after\"][pkk]\n                              }\\n`\n                            : ``;\n                    })\n                    .join(\"\");\n                logSuccess(packagesListAfter);\n            } catch (e) {\n                logError(`${command} - ${e}`);\n            }\n        }\n    }\n};\nmodule.exports = upgradePackages;\n","const chalk = require(\"chalk\");\nconst path = require(\"path\");\nconst moment = require(\"moment\");\nconst spawn = require(\"cross-spawn\");\n\nmodule.exports = async ({ script, task, type = script.type }, quiet = false) => {\n    if (!quiet) {\n        console.log(\n            `${chalk.green\n                .bgHex(\"#181c24\")\n                .bold(\"[\" + moment().format(\"HH:MM:SS\") + \"]\")}${chalk\n                .bgHex(\"#181c24\")\n                .bold.hex(\"#8c91a7\")(\" \" + task.name + \": \")}`\n        );\n    }\n    return new Promise(resolve => {\n        const cmd = spawn(type, [...script.rest], {\n            stdio: \"inherit\",\n            env: Object.assign({}, process.env, {\n                FORCE_COLOR: true,\n                PATH: `${path.resolve(\"node_modules/.bin\")}:${process.env.PATH}`\n            })\n        });\n\n        cmd.on(\"close\", code => {\n            if (code === 0) {\n                resolve();\n            } else {\n                console.error(`${chalk.red(\"ERROR\")} ${code}`);\n            }\n        });\n    });\n};\n","const runCLICommand = require(\"./runCLICommand\");\nconst chalk = require(\"chalk\");\n\nconst runSequence = async (tasks, FcScripts) => {\n    for (let t in tasks) {\n        let taskName = tasks[t];\n        let taskIndex = FcScripts.allTasks.findIndex(t => t.name === taskName);\n        if (taskIndex === -1) {\n            console.log(\n                `${chalk.red.underline(\n                    \"Skipping task \" + taskName + \", as it cannot be found in .md file\"\n                )}`\n            );\n        } else {\n            let script = FcScripts.allTasks[taskIndex].script;\n            let params = script.split(\" \");\n            let type = params.shift();\n            await runCLICommand({\n                task: { name: taskName },\n                script: {\n                    type: type,\n                    rest: params\n                }\n            });\n        }\n    }\n};\n\nmodule.exports = runSequence;\n// (async () => {\n//     await startScripts();\n// })();\n","const runCLICommand = require(\"./runCLICommand\");\n\nconst runParallel = async (tasks, FcScripts) => {\n    for (let t in tasks) {\n        let taskName = tasks[t];\n        let taskIndex = FcScripts.allTasks.findIndex(t => t.name === taskName);\n        let script = FcScripts.allTasks[taskIndex].script;\n        let params = script.split(\" \");\n        let type = params.shift();\n\n        runCLICommand({\n            task: { name: taskName },\n            script: {\n                type: type,\n                rest: params\n            }\n        });\n    }\n};\n\nmodule.exports = runParallel;\n","const inquirer = require(\"inquirer\");\nconst separator = \"   ~   \";\nconst chalk = require(\"chalk\");\nconst convertBold = e => {\n    let reg = /(\\*\\*|^\\*\\*)(?=\\S)([\\s\\S]*?\\S)\\*\\*(?![\\*\\*\\S])/g;\n    let boldMatches = e.match(reg);\n    if (boldMatches !== null) {\n        boldMatches.forEach(m => {\n            e = e.replace(m, chalk.bold.redBright(m.replace(/\\*\\*/g, \"\"))); //.underline.bgBlack.whiteBright\n        });\n    }\n    let regunderline = /(_|^_)(?=\\S)([\\s\\S]*?\\S)_(?![_\\S])/g;\n    let underlineMatches = e.match(regunderline);\n    if (underlineMatches !== null) {\n        underlineMatches.forEach(m => {\n            e = e.replace(m, chalk.underline.greenBright(m.replace(/\\_\\_/g, \"\"))); //.underline.bgBlack.whiteBright\n        });\n    }\n    return e;\n};\nconst convertBoldArray = arr => {\n    return arr.map(e => {\n        return convertBold(e);\n    });\n};\nconst taskList = async (FcScripts, recentTasks) => {\n    return new Promise(resolve => {\n        let choiceCategories = [\n            ...recentTasks.map(cat => {\n                return {\n                    name: `${chalk.bold.underline.green(cat)}`,\n                    value: { type: \"task\", name: cat }\n                };\n            }),\n            { name: \"-------------\", value: null },\n            ...FcScripts.categories.map(cat => {\n                return {\n                    name: `${chalk.bold.underline.green(cat.name)} ${separator} ${convertBold(\n                        cat.description\n                    )}`,\n                    value: { type: \"category\", name: cat.name }\n                };\n            })\n        ];\n        inquirer\n            .prompt([\n                {\n                    type: \"list\",\n                    name: \"category\",\n                    message: \"What category do you want to run?\",\n                    pageSize: 10,\n                    choices: choiceCategories\n                }\n            ])\n            .then(({ category }) => {\n                let sepInd = choiceCategories.indexOf(\"-------------\");\n                let chosenInd = choiceCategories.indexOf(category);\n                if (category === null) {\n                    console.log(\"Can't select divider\");\n                } else if (category.type === \"task\") {\n                    let taskToRun = category.name.split(separator)[0].trim();\n                    resolve(taskToRun);\n                } else {\n                    let categoryName = category.name.split(separator)[0];\n                    let catObj = FcScripts.categories.findIndex(e => e.name === category.name);\n                    catObj = FcScripts.categories[catObj];\n                    let taskNames = Object.keys(catObj.tasks).map(taskName => {\n                        let task = catObj.tasks[taskName];\n                        return `${taskName} ${\n                            task.description\n                                ? separator + task.description.replace(/\\n/g, \" \").trim()\n                                : \"\"\n                        }`;\n                    });\n                    taskNames = convertBoldArray(taskNames);\n                    inquirer\n                        .prompt([\n                            {\n                                type: \"list\",\n                                name: \"taskToRun\",\n                                message: \"Which task do you want to run\",\n                                choices: taskNames\n                            }\n                        ])\n                        .then(({ taskToRun }) => {\n                            taskToRun = taskToRun.split(separator)[0].trim();\n                            resolve(taskToRun);\n                        });\n                }\n            });\n    });\n};\n\nmodule.exports = taskList;\n","\"use strict\";\nconst path = require(\"path\");\nconst chalk = require(\"chalk\");\nconst projectPath = path.join(process.cwd(), \"./package.json\");\nconst { readJson } = require(\"./helpers\");\nconst parseScriptFile = async () => {\n    const packageFile = await readJson(projectPath);\n    return packageFile.scripts;\n};\n\nmodule.exports = parseScriptFile;\n","const taskList = require(\"./taskList\");\nconst separator = \"   ~   \";\nconst Conf = require(\"conf\");\nconst config = new Conf();\nconst moment = require(\"moment\");\nconst chalk = require(\"chalk\");\nconst parseScriptFile = require(\"./parseScriptsMd.js\");\nconst parsePackageFile = require(\"./parseScriptsPackage.js\");\nconst runCLICommand = require(\"./runCLICommand\");\nconst { prompt } = require(\"enquirer\");\n\nconst taskListAutoComplete = async tasks => {\n    try {\n        let { answer } = await prompt({\n            type: \"autocomplete\",\n            message: `${chalk.green.bold.underline(\"Choose task to run\")}`,\n            choices: tasks,\n            name: `answer`\n        });\n        return answer.split(separator)[0].trim();\n    } catch (e) {\n        return false;\n    }\n};\n\nconst startScripts = async (categories = true) => {\n    console.clear();\n    const FcScripts = await parseScriptFile();\n    if (FcScripts === false) {\n        return false;\n    }\n    let recentTasks = config.get(\"recentTasks\", {});\n    let recentTaskArr = Object.keys(recentTasks)\n        .map(taskName => {\n            let task = recentTasks[taskName];\n            return { name: taskName, lastExecuted: task.lastExecuted };\n        })\n        .sort((a, b) =>\n            a.lastExecuted > b.lastExecuted ? 1 : b.lastExecuted > a.lastExecuted ? -1 : 0\n        )\n        .reverse()\n        .slice(0, 3);\n    let recentTaskOptions = recentTaskArr.map(task => {\n        return task.name + separator + moment(task.lastExecuted).calendar();\n    });\n    let taskToRun;\n    if (categories) {\n        taskToRun = await taskList(FcScripts, recentTaskOptions);\n    } else {\n        let tasks = FcScripts.allTasks;\n\n        taskToRun = await taskListAutoComplete(\n            tasks.map(task => {\n                return `${task.name}${separator}${task.description}`;\n            })\n        );\n    }\n    if (recentTasks[taskToRun] === undefined) {\n        recentTasks[taskToRun] = { lastExecuted: Date.now() };\n    } else {\n        recentTasks[taskToRun].lastExecuted = Date.now();\n    }\n    config.set(\"recentTasks\", recentTasks);\n    let taskIndex = FcScripts.allTasks.findIndex(t => t.name === taskToRun);\n    let script = FcScripts.allTasks[taskIndex].script;\n    let params = script.split(\" \");\n    let type = params.shift();\n    await runCLICommand({\n        task: { name: taskToRun },\n        script: {\n            type: type,\n            rest: params\n        }\n    });\n};\n\nconst startPackageScripts = async () => {\n    console.clear();\n    const packageScripts = await parsePackageFile();\n    let tasks = Object.keys(packageScripts).map(e => {\n        return { name: e, script: packageScripts[e] };\n    });\n\n    let taskToRun = await taskListAutoComplete(\n        tasks.map(task => {\n            return `${task.name}${separator}${task.script}`;\n        })\n    );\n    if (taskToRun === false) {\n        console.log(chalk.green.bold(\"See you soon!\"));\n        return false;\n    }\n    await runCLICommand({\n        task: { name: taskToRun },\n        script: {\n            type: \"yarn\",\n            rest: [taskToRun]\n        }\n    });\n};\n\nconst clearRecent = async () => {\n    config.set(\"recentTasks\", {});\n};\nmodule.exports = {\n    startScripts,\n    taskListAutoComplete,\n    clearRecent,\n    startPackageScripts\n};\n","const separator = \"   ~   \";\nconst chalk = require(\"chalk\");\n\nconst { prompt } = require(\"enquirer\");\nconst optionList = async () => {\n    let choiceCategories = [\n        {\n            name: \"start\",\n            message: \"Choose category then task to run\"\n        },\n        {\n            name: \"list\",\n            message: \"Select any task with text autocompletion\"\n        },\n        {\n            name: \"scripts\",\n            message: \"Choose a script from package.json\"\n        },\n        {\n            name: \"upgrade\",\n            message: \"Upgrade all your packages except ones specified by 'ignore-upgrade':[]\"\n        },\n        {\n            name: \"bump\",\n            message: \"Bump package.json and beautify it!\"\n        },\n        {\n            name: \"encryption\",\n            message: \"Encrypt/Decrypt secret files\"\n        },\n        {\n            name: \"clear\",\n            message: \"Clear recent task history\"\n        },\n        {\n            name: \"generate\",\n            message: \"Generate a sample fscripts.md file from the package.json\"\n        },\n        {\n            name: \"toc\",\n            message: \"Generate updated Table of Contents on top of the fscripts.md file\"\n        },\n        {\n            name: \"--help\",\n            message: \"See full help documentation\"\n        }\n    ];\n    try {\n        let { answer } = await prompt({\n            type: \"select\",\n            name: `answer`,\n            choiceMessage: e => {\n                // return JSON.stringify(e)\n                // return e.message;\n                return chalk.bold.underline.black(e.name + \":\" + chalk.gray(\" \" + e.message));\n            },\n            message: `${chalk.cyan.bold.underline(\"Whatz category do you want to run?\")}`,\n            choices: choiceCategories\n        });\n        return answer;\n    } catch (e) {\n        return false;\n    }\n};\n\nmodule.exports = optionList;\n","const inquirer = require(\"inquirer\");\nconst chalk = require(\"chalk\");\nconst boxen = require(\"boxen\");\nconst { boxInform } = require(\"../helpers.js\");\nconst git = require(\"git-state\");\nconst simple = require(\"simple-git\");\nconst pathToCwd = process.cwd();\n\nconst newBranch = async name => {\n    // const last = await new Promise(rzz => {\n    //     git.isGit(pathToCwd, function(exists) {\n    //         if (!exists) return;\n\n    //\n    //         git.commit(pathToCwd, function(err, result) {\n    //             if (err) throw err;\n    //             rzz(result);\n    //         });\n    //     });\n    // });\n\n    try {\n        // logInfo(command);\n       childProcess.execSync(\n            `git -c core.quotepath=false -c log.showSignature=false checkout -b ${name}`,\n            {\n                stdio: \"inherit\",\n                env: Object.assign({}, process.env, {\n                    FORCE_COLOR: true,\n                    PATH: `${path.resolve(\"node_modules\")}:${process.env.PATH}`\n                })\n            }\n        );\n    } catch (e) {}\n\n    // await simple().checkoutLocalBranch(name);\n    // await simple().checkoutBranch(name, \"origin\");\n    boxInform(chalk.green(`New branch ${name} created`, \"\", 5));\n};\n\nasync function pub() {\n    return new Promise(resolve => {\n        inquirer\n            .prompt([\n                {\n                    type: \"input\",\n                    message: chalk.bold.hex(\"#38be18\")(`Name new feature branch (or type cancel):`),\n                    name: \"branchname\"\n                }\n            ])\n            .then(async ({ branchname }) => {\n                if (branchname !== \"Development\") await newBranch(branchname);\n                resolve();\n            });\n    });\n}\n\nconst validateNotInDev = async () => {\n    await new Promise(async resolve => {\n        const git = require(\"simple-git/promise\");\n\n        let statusSummary = await git(__dirname).status();\n        if (statusSummary.current === \"Development\") {\n            console.clear();\n            console.log(\n                boxen(chalk.bold.underline.red(\"DO NO MAKE CHANGES IN DEV!\"), {\n                    padding: 2\n                })\n            );\n            await new Promise(resolve1 =>\n                setTimeout(() => {\n                    resolve1();\n                }, 1000)\n            );\n            await pub();\n            resolve();\n        } else {\n            resolve();\n        }\n    });\n};\nmodule.exports = validateNotInDev;\n","const CryptoJS = require(\"crypto-js\");\nconst chalk = require(\"chalk\");\nvar inquirer = require(\"inquirer\");\n\nconst {\n    appendToFile,\n    ensureFile,\n    writeFile,\n    boxInform,\n    readJson,\n    readFile\n} = require(\"../helpers.js\");\nconst path = require(\"path\");\nconst scriptsDir = process.cwd();\nconst rootDir = path.join(scriptsDir, \"./\");\nconst packagePath = path.join(rootDir, \"package.json\");\nconst igPath = path.join(rootDir, \".gitignore\");\nconst prettier = require(\"prettier\");\nconst encrypt = { encryptedFiles: [] };\n\n// prettier-ignore\nencrypt.encrypt = async (pass, encryptedFile, decryptedFile) => {\n    let willEncrypt = true;\n    let sureSure = await ensureFile(encryptedFile);\n    if (sureSure) {\n        console.log(`${chalk.bold.red(\"FILE ALREADY EXISTS ARE YOU SURE?\")}`);\n        willEncrypt = await new Promise(resolve => {\n            inquirer\n                .prompt([\n                    {\n                        type: \"confirm\",\n                        message: chalk.bold.hex(\"#38be18\")(`Sure? (y/n): `),\n                        name: \"sure\"\n                    }\n                ])\n                .then(({ sure }) => {\n                    resolve(sure);\n                });\n        });\n    }\n    if (willEncrypt) {\n        let toEncrypt = await readFile(decryptedFile);\n        const ciphertext = CryptoJS.AES.encrypt(toEncrypt, pass);\n        await writeFile(encryptedFile, ciphertext.toString());\n    }\n\n};\n// prettier-ignore\nencrypt.decrypt = async (pass, encryptedFileLocation, decryptedFileLocation) => {\n    // let encryptedFileLocation = path.join(rootDir,\".\"+encryptedFile);\n    // let decryptedFileLocation = path.join(rootDir,encryptedFile);\n    let willEncrypt = true;\n    let sureSure = await ensureFile(decryptedFileLocation);\n    if (sureSure) {\n        console.log(`${chalk.bold.red(\"FILE ALREADY EXISTS ARE YOU SURE?\")}`);\n        willEncrypt = await new Promise(resolve => {\n            inquirer\n                .prompt([\n                    {\n                        type: \"confirm\",\n                        message: chalk.bold.hex(\"#38be18\")(`Sure wanna override file ${decryptedFileLocation}? (y/n): `),\n                        name: \"sure\"\n                    }\n                ])\n                .then(({ sure }) => {\n                    resolve(sure);\n                });\n        });\n    }\n    if (willEncrypt) {\n        let toDecrypt = await readFile(encryptedFileLocation);\n        const bytes = CryptoJS.AES.decrypt(toDecrypt, pass);\n        let decryptedData;\n        try {\n            decryptedData = bytes.toString(CryptoJS.enc.Utf8);\n        } catch (e) {\n            console.error(\"-- Console Problem \", e);\n        }\n        await writeFile(decryptedFileLocation, decryptedData);\n        console.warn(`${chalk.bold.green.underline(\"DECRYPTED FILE:\")} ${chalk.bold.dim(path.join(scriptsDir, decryptedFileLocation))}`);\n    }\n\n};\n\nencrypt.init = async () => {\n    try {\n        let pass = await encrypt.getPass();\n        let toEncrypt = await encrypt.toEncrypt();\n        encrypt.packageJson = await readJson(packagePath);\n        encrypt.ignore = await readFile(igPath);\n        encrypt.ignoredFiles = encrypt.ignore.split(\"\\n\");\n        if (encrypt.packageJson.fscripts) {\n            if (encrypt.packageJson.fscripts.encryptedFiles) {\n                encrypt.encryptedFiles = encrypt.packageJson.fscripts.encryptedFiles;\n                let filesToAdd = \"\\n\";\n                for (const e of encrypt.encryptedFiles) {\n                    if (encrypt.ignoredFiles.indexOf(e) === -1) {\n                        filesToAdd += e + \"\\n\";\n                    }\n                    let file = e + \"\";\n                    let fileSplit = file.split(\"/\");\n                    let name = fileSplit.pop();\n                    let encryptedFile = fileSplit.slice();\n                    let decryptedFile = fileSplit.slice();\n                    encryptedFile.push(\".\" + name);\n                    encryptedFile = path.join(rootDir, encryptedFile.join(\"/\"));\n                    decryptedFile.push(name);\n                    decryptedFile = path.join(rootDir, decryptedFile.join(\"/\"));\n\n                    if (toEncrypt) {\n                        await encrypt.encrypt(pass, encryptedFile, decryptedFile);\n                    } else {\n                        await encrypt.decrypt(pass, encryptedFile, decryptedFile);\n                    }\n                }\n\n                if (filesToAdd.trim().length > 0) {\n                    await appendToFile(igPath, filesToAdd + \"\\n\");\n                    boxInform(\" Added files to .gitignore: \", filesToAdd);\n                }\n            }\n        }\n    } catch (err) {\n        console.error(err);\n    }\n};\n\nencrypt.getPass = async () => {\n    return await new Promise(resolve => {\n        inquirer\n            .prompt([\n                {\n                    type: \"password\",\n                    mask: chalk.underline(\" ●\"),\n                    message: chalk.bold.hex(\"#38be18\")(`Enter a SECRET key (same as pass app) : `),\n                    name: \"pass\"\n                }\n            ])\n            .then(({ pass }) => {\n                resolve(pass);\n            });\n    });\n};\nencrypt.toEncrypt = async () => {\n    return await new Promise(resolve => {\n        inquirer\n            .prompt([\n                {\n                    type: \"list\",\n                    message: chalk.bold.hex(\"#38be18\")(\"Which direction?\"),\n                    choices: [\"encrypt\", \"decrypt\"],\n                    name: \"encryptDecrypt\"\n                }\n            ])\n            .then(async ({ encryptDecrypt }) => {\n                resolve(encryptDecrypt === \"encrypt\");\n            });\n    });\n};\n\nmodule.exports = { ...encrypt };\n","#!/usr/bin/env node\nconst bump = require(\"./lib/release/bump.js\");\nconst chalk = require(\"chalk\");\nconst generateFScripts = require(\"./lib/generateFScripts.js\");\nconst parseScriptFile = require(\"./lib/parseScriptsMd.js\");\n// const parseScriptPackage = require(\"./lib/parseScriptsPackage\");\nconst generateToc = require(\"./lib/generateToc\");\nconst upgradePackages = require(\"./lib/upgradePackages\");\nconst runSequence = require(\"./lib/runSequence\");\nconst runParallel = require(\"./lib/runParallel\");\nconst runCLICommand = require(\"./lib/runCLICommand\");\nconst { startPackageScripts, startScripts, clearRecent } = require(\"./lib/startScripts.js\");\nconst taskName = chalk.rgb(39, 173, 96).bold.underline;\nconst textDescription = chalk.rgb(159, 161, 181);\nconst optionList = require(\"./lib/optionList\");\nconst validateNotInDev = require(\"./lib/git/validateNotDev.js\");\nconst encrypt = require(\"./lib/encryption/encryption\");\n\n(async () => {\n    const argv = require(\"yargs\")\n        .usage(\"Usage: $0 <command> [options]\")\n\n        /**\n         *  fsr\n         */\n        .command(\"\", \"Choose a script runner command\", yargs => {}, async function() {})\n        .example(`${taskName(\"$0\")}`, `${textDescription(\"Choose a script runner command\")}`)\n\n        /**\n         *  fsr\n         */\n        .command(\n            \"branch\",\n            \"Create new branch instead of Development\",\n            yargs => {},\n            async function() {\n                await validateNotInDev();\n            }\n        )\n        .example(`${taskName(\"$0\")}`, `${textDescription(\"Validates branch and creates new\")}`)\n\n        /**\n         * fsr\n         * start --\n         */\n        .command(\"start\", \"Choose category then task to run\", yargs => {}, async function() {\n            if ((await startScripts()) === false) {\n                await startPackageScripts();\n            }\n        })\n        .example(`${taskName(\"$0 start\")}`, `${textDescription(\"Open a task selection selector\")}`)\n\n        /**\n         * fsr\n         * scripts --\n         */\n        .command(\"scripts\", \"Choose a script from package.json\", yargs => {}, async function() {\n            await startPackageScripts();\n        })\n        .example(\n            `${taskName(\"$0 scripts\")}`,\n            `${textDescription(\"Choose a script from package.json\")}`\n        )\n\n        /**\n         * fsr\n         * list --\n         */\n        .command(\"list\", \"Select any task with text autocompletion\", () => {}, async function(\n            argv\n        ) {\n            await startScripts(false);\n            // const tasks = await scriptsParsed().allTasks;\n        })\n        .example(`${taskName(\"$0 list\")}`, `${textDescription(\"Show you all tasks you can run\")}`)\n\n        /**\n         * fsr\n         * run --\n         */\n        .command(\"run\", \"Run a specific task\", () => {}, async function(argv) {\n            let task = argv._[1];\n            const FcScripts = await parseScriptFile();\n            let taskIndex = FcScripts.allTasks.findIndex(t => t.name === task);\n            let taskData = FcScripts.allTasks[taskIndex];\n            let runCommand = taskData[\"script\"].split(\" \");\n            let type = runCommand.shift();\n            let params = runCommand.join(\" \");\n            let args = Object.keys(argv)\n                .filter(e => e !== \"_\" && e !== \"$0\")\n                .map(e => ` --${e}=${argv[e]}`);\n            params += \" \" + args.join(\" \");\n            await runCLICommand({\n                task: { name: task },\n                script: {\n                    type: type,\n                    rest: params.split(\" \")\n                }\n            });\n        })\n        .example(`${taskName(\"$0 run start:web\")}`, `${textDescription(\"Run task 'start:web'\")}`)\n\n        /**\n         * fsr\n         * upgrade --\n         */\n        .command(\n            \"upgrade\",\n            \"Upgrade all your packages except ones specified by 'ignore-upgrade':[]\",\n            () => {},\n            async function(argv) {\n                let task = argv._[1];\n                await upgradePackages();\n            }\n        )\n        .example(`${taskName(\"$0 upgrade\")}`, `${textDescription(\"Upgraded!\")}`)\n\n        /**\n         * fsr\n         * bump --\n         */\n        .command(\"bump\", \"Bump package.json and beautify it!\", () => {}, async function(argv) {\n            let shouldNotPretty = argv.pretty;\n            let type = argv.type;\n            await bump(shouldNotPretty, type);\n        })\n        .example(`${taskName(\"$0 bump\")}`, `${textDescription(\"BUMPED AND PRETTY!\")}`)\n\n        /**\n         * fsr\n         * run-s --\n         */\n        .command(\"run-s\", \"Run a set of tasks one after another\", () => {}, async function(argv) {\n            let tasks = argv._.slice();\n            tasks.shift();\n            const FcScripts = await parseScriptFile();\n            await runSequence(tasks, FcScripts);\n        })\n        .example(\n            `${taskName(\"$0 run-s start:web start:desktop\")}`,\n            `${textDescription(\"Run task 'start:web' and afterwards 'start:desktop'\")}`\n        )\n\n        /**\n         * fsr\n         * run-p --\n         */\n        .command(\"run-p\", \"Run tasks in parallel\", () => {}, async function(argv) {\n            let tasks = argv._.slice();\n            tasks.shift();\n            const FcScripts = await parseScriptFile();\n            await runParallel(tasks, FcScripts);\n        })\n        .example(\n            `${taskName(\"$0 run-p start:web start:desktop\")}`,\n            `${textDescription(\"Run task 'start:web' and at the same time 'start:desktop'\")}`\n        )\n\n        /**\n         * fsr\n         * encryption --\n         */\n        .command(\"encryption\", \"Encrypt/Decrypt secret files\", () => {}, async function(argv) {\n            await encrypt.init();\n        })\n        .example(\n            `${taskName(\"$0 encryption\")}`,\n            `${textDescription(\"Encrypt/Decrypt secret files\")}`\n        )\n\n        /**\n         * fsr\n         * clear --\n         */\n        .command(\"clear\", \"Clear recent task history\", () => {}, async function(argv) {\n            await clearRecent();\n        })\n        .example(`${taskName(\"$0 clear\")}`, `${textDescription(\"Clear your recently run tasks\")}`)\n        .command(\n            \"generate\",\n            \"Generate a sample fscripts.md file from the package.json\",\n            () => {},\n            async function(argv) {\n                await generateFScripts();\n            }\n        )\n        .example(\n            `${taskName(\"$0 generate\")}`,\n            `${textDescription(\n                \"Generates a sample.fscripts.md you can use as template for your fscripts file\"\n            )}`\n        )\n        .command(\n            \"toc\",\n            \"Generate updated Table of Contents on top of the fscripts.md file\",\n            () => {},\n            async function(argv) {\n                await generateToc();\n            }\n        )\n        .example(\n            `${taskName(\"$0 toc\")}`,\n            `${textDescription(\n                \"Generate updated Table of Contents on top of the fscripts.md file\"\n            )}`\n        ).argv;\n\n    if (argv._.length === 0) {\n        (async function() {\n            const choice = await optionList();\n            if (choice) {\n                await runCLICommand(\n                    { task: { name: choice }, script: { type: \"fsr\", rest: [choice] } },\n                    true\n                );\n            } else {\n                console.log(chalk.green.bold(\"See you soon!\"));\n            }\n        })();\n    }\n})();\n"]}